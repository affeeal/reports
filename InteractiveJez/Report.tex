\documentclass[12pt]{article}

\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{minted}

\AddToHook{cmd/section/before}{\clearpage}

\hypersetup{
  colorlinks=true,
  citecolor=blue,
  linkcolor=blue,
  urlcolor=blue
}

\def\mir#1{\mintinline{Lexer.py:RefalLexer -x}{#1}} % Mint Inline Refal

\begin{document}

\tableofcontents

\section{Описание предприятия}

Институт программных систем был создан в апреле 1984 года как Филиал Института
проблем кибернетики АН СССР по решению Правительства СССР, направленному на
развитие вычислительной техники и информатики в стране. Руководителем ФИПК АН
СССР был назначен д.т.н., профессор Альфред Карлович Айламазян. В 1986 году
Филиал Института проблем кибернетики был преобразован в Институт программных
систем АН СССР, а в 2008 году институту было присвоено имя его первого
директора профессора А.К. Айламазяна. С момента создания основными научными
направлениями деятельности института являлись:
\begin{itemize}
\item высокопроизводительные вычисления;
\item программные системы для параллельных архитектур;
\item автоматизация программирования;
\item телекоммуникационные системы и медицинская информатика.
\end{itemize}
Сегодня Институт программных систем имени А.К. Айламазяна РАН объединяет пять
исследовательских центров и является динамично развивающимся коллективом,
работающим в Отделении нанотехнологий и информационных технологий РАН.

Исследовательские центры ИПС РАН:
\begin{itemize}
\item Исследовательский центр мультипроцессорных систем (ИЦМС);
\item Исследовательский центр медицинской информатики (ИЦМИ Интерин);
\item Исследовательский центр искусственного интеллекта (ИЦИИ); 
\item Исследовательский центр процессов управления (ИЦПУ);
\item Исследовательский центр системного анализа (ИЦСА).
\end{itemize}



\section{Индивидуальное задание}

Практическое задание заключается в реализации базового шага алгоритма
рекомпрессии Артура Ежа для решения уравнений в словах \cite{jez}.
Предполагается реализация двух программных модулей:
\begin{itemize}
\item \texttt{PairComp} --- сжатие всех вхождений в уравнение данной пары
констант с ветвлением исходного уравнения;
\item \texttt{BlockComp} --- сжатие всех вхождений данной константы в блоки
максимальной длины, также с порождением новых ветвей.
\end{itemize}
Указанные модули являются частью интерактивного режима с визуализацией,
который позволит удобно исследовать вопрос эффективности алгоритма Ежа с
применением различных эвристик. В частности, для управления рабочим процессом
интерактивного режима необходимы две вспомогательные функции:
\begin{itemize}
\item \texttt{Pick}, выбирающая одну из ветвей уравнения для дальнейшей работы;
\item \texttt{SubstIndex} для подстановки переменных индексов в константы-блоки.
\end{itemize}
Формат и назначение всех указанных функций будут подробны описаны в разделах 
\ref{pick}-\ref{blockComp}, а листинги --- представлены в \ref{code}. Вся
необходимая теоретическая база сосредоточена в разделе \ref{base}. Теории,
вообще, уделено много внимания в настоящем отчёте: как и программная,
теоретическая часть тоже выводилась и систематизировалась в процессе практики.

В качестве языка реализации был выбран Рефал-5, отлично подходящий для анализа
и преобразования текстов вообще и математических структур в частности. Весь
исходный код и различные полезные материалы, относящиеся к практике, доступны
в репозитории \href{https://github.com/TonitaN/Misc-Lectures}
{github.com/TonitaN/Misc-Lectrues}.



\section{Цели}

Условием успешного прохождения производственной практики я определил для себя
осуществление следующих целей.
\begin{itemize}
\item \emph{Качественная реализация программных модулей \texttt{PairComp},
\texttt{BlockComp} и функций \texttt{Pick}, \texttt{SubstIndex} для
эффективной работы интерактивного режима}.
\end{itemize}
Под словом \emph{качественная} понимается ясность и структурированность,
быстродействие и результативность написанной программы.
\begin{itemize}
\item \emph{Исследование и систематизация теоретической части практической
применимости алгоритма Ежа.}
\end{itemize}
С момента своей публикации (2012 год \cite{jez}) техника повторного сжатия
рассматривалась как хороший \emph{теоретический}, но не \emph{практический}
метод решения уравнений в словах. Однако с применением даже некоторых эвристик
--- \emph{разрезание уравнения} и \emph{подсчёт баланса букв}, разработкой
которых занимается мой научный руководитель А.Н. Непейвода --- техника
рекомпрессии может стать мощным прикладным инструментом в своей области.
\begin{itemize}
\item \emph{Изучение языка Рефал-5, различных методов программирования,
характерных для данного языка и функциональной парадигмы вообще, c применением
хороших практик написания Рефал-кода.}
\end{itemize}
Специализация языка на работе со строковыми моделями влечёт совершенно отличный
от многих современных ЯП способ \emph{мышления} и, как следствие, написания
программ --- тем лично мне и интересен Рефал. Для его грамотного применения
в работе стараюсь придерживаться рекомендаций А.В. Коновалова
\cite{konovalov-format}, \cite{konovalov-style} по оформлению кода.



\section{Теоретическая основа} \label{base}

При описании структур данных используется формальная БНФ-грамматика. Все
литералы имеют один из трёх префиксов: \texttt{s.}, \texttt{t.} или
\texttt{e.}, соответствующие \textit{символам}, \textit{термам} и
\textit{объектным выражениям} языка Рефал.

Помимо явных символьных слов (\texttt{AreEqual}, \texttt{Var} и т.п.)
используются следующие терминалы:
\begin{itemize}
  \item \texttt{s.NUMBER} --- любая макроцифра; 
  \item \texttt{s.CHAR} --- любой символ; 
  \item \texttt{s.WORD} --- любое символьное слово.
  \item \texttt{e.ANY} --- любое объектное выражение.
\end{itemize}
В определении литерала заместо \texttt{::=} может использоваться инфиксный
оператор \texttt{:} в случае, когда \textit{лишь в данном контексте}
выражение слева представляется как выражение справа. Символы \texttt{*} и
\texttt{+} означают повторение литерала ноль и более и один и более раз
соответственно.


\subsection{Представление уравнения}

Рассматриваются уравнения в словах с алфавитом переменных $\Xi$ и алфавитом
констант $\Sigma$. Применение алгоритма Ежа предполагает хранение
дополнительной информации об уравнении: какие константы являются результатом
сжатия блоков, какие переменные не могут быть пусты и т.д. Поэтому
\textit{уравнение} представляется структурой данных \texttt{t.Eq}:
\begin{Verbatim}
  t.Eq ::= ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds)),
\end{Verbatim}
где \texttt{e.LHS: t.Elem*} и \texttt{e.RHS: t.Elem*} представляют его левую и
правую части, \texttt{e.Constrs: t.Constr*} --- ограничения на переменные,
а \texttt{e.Conds: t.Cond*} содержит условия на константы.

\textit{Элемент} \texttt{t.Elem} обобщённо представляет \textit{константу} или
\textit{переменную}, соответствующие структурам данных \texttt{t.Const} и
\texttt{t.Var}:
\begin{Verbatim}
  t.Elem ::= t.Const | t.Var,
  t.Const ::= (s.CHAR s.NUMBER),
  t.Var ::= (Var s.CHAR).
\end{Verbatim}


\subsection{Ограничения на переменные}

\textit{Ограничения на переменные} представляются структурой \texttt{t.Constr}
и описываются в конъюнктивной нормальной форме. Литералами дизъюнкций являются
\textit{рестрикции} --- отрицательные условия на переменные типа
\texttt{t.Restr}, подразделяющиеся на \textit{краевые} \texttt{t.BoundRestr} и
рестрикции \textit{на пустоту} \\ \texttt{t.EmptyRestr}:
\begin{Verbatim}
  t.Restr ::= t.BoundRestr | t.EmptyRestr.
\end{Verbatim}
Краевые рестрикции бывают \textit{префиксными} \texttt{t.PrefixRestr} и
\textit{суффиксными} \texttt{t.SuffixRestr}. Они указывают, на какие константы
не может начинаться или кончаться данная переменная.
\begin{Verbatim}
  t.BoundRestr ::= t.PrefixRestr | t.SuffixRestr,
  t.PrefixRestr ::= (not t.Const starts t.Var),
  t.SuffixRestr ::= (not t.Const ends t.Var).
\end{Verbatim}
Рестрикция на пустоту \texttt{t.EmptyRestr} сообщает, как следует, о
невозможности обращения данной переменной в пустое слово $\varepsilon$:
\begin{Verbatim}
  t.EmptyRestr ::= (not empty t.Var).
\end{Verbatim}
В частности, будем называть переменную \textbf{непустой}, если для неё
существует такая рестрикция.

Ограничения на переменные \texttt{t.Constr} могут содержать одну или две
рестрикции, в соответствии с чем называются \textit{тривиальными}
\texttt{t.TrivialConstr} и \textit{нетривиальными} \texttt{t.NonTrivialConstr}.
В программе используется только четыре вида ограничений:
\begin{Verbatim}
  t.Constr ::= t.TrivialConstr | t.NonTrivialConstr
  t.TrivialConstr ::= (OR t.Restr),
  t.NonTrivialConstr ::= (OR t.SuffixRestr t.PrefixRestr).
\end{Verbatim}
Говоря далее \textit{ограничения} мы, как правило, будем подразумевать именно
тривиальные, если не оговорено противное, а также будем экстраполировать
тип рестрикции на ограничение её содержащее: префиксное ограничение,
ограничение на пустоту и т.д.


\subsection{Условия на константы}

\textit{Условие на константу} \texttt{t.Cond} содержит сжимаемые блоки и
соотвествующую этому сжатию константу. Вообще, \textit{блок} \texttt{t.Block}
обозначает степень константы и представляется в виде
\begin{Verbatim}
  t.Block ::= (t.Const t.Exp* (const s.NUMBER)),
\end{Verbatim}
где \texttt{t.Const} --- сжимаемая константа, \texttt{(const s.NUMBER)} ---
обязательный константный показатель, а \texttt{t.Exp ::= (s.WORD s.NUMBER)}
--- переменный показатель степени. Таким образом, условие на константу
представляется в виде
\begin{Verbatim}
  t.Cond ::= (t.Const is t.Block+).
\end{Verbatim}
В программе используется только два типа условий: \textit{парное}
\texttt{t.PairCond} и \textit{условие на блок} \texttt{t.BlockCond}:
\begin{Verbatim}
  t.PairCond ::= (t.Const is (t.Const (const 1)) (t.Const (const 1))),
  t.BlockCond ::= (t.Const is t.Block).
\end{Verbatim}


\subsection{Краевые элементы} \label{base-bound}

Мы хотим применять \texttt{Pair}- и \texttt{Block}-сжатие не только к
обыкновенным константам, но и тем, что уже являются результатом сжатия в блоки.
Для корректной обработки ограничений необходимо аккуратно отслеживать, на какие
константы не может начинаться или кончаться та или иная переменная.

Пусть $\alpha, \gamma \in \Sigma$. Скажем, что $\alpha \in First(\gamma)$, если
существует цепочка условий на константы такая, что
\begin{displaymath}
  \gamma = \beta_1^{i_1} B_1, \quad \beta_1 = \beta_2^{i_2} B_2, \quad
  \dots, \quad \beta_{n-1} = \alpha^{i_n} B_n,
\end{displaymath}
где $\beta_i \in \Sigma, \ i = 1, 2, \dots, n - 1$, и $B_j \in \Sigma^*,
\ j = 1, 2, \dots, n$. Симметрично определяется множество $Last$-элементов
константы (вообще, делая далее какое-либо утверждение о $First$-элементах
константы будем считать, что оно симметрично выполняется и для её
$Last$-множества).

Иногда удобно использовать обобщение введённых выше понятий: будем
говорить, что константа $\alpha$ является \textbf{краевым} элементом константы
$\gamma$, если $\alpha \in First(\gamma)$ или $\alpha \in Last(\gamma)$.
Обозначение: $\alpha \in Bound(\gamma)$.


\subsection{Слабые и сильные ограничения}

В соответствии с введённым в разделе \ref{base-bound} понятием краевого
элемента, для данной переменной $X$ и константы $\gamma$ мы можем определить
\textit{иерархические отношения} на множествах префиксных и суффиксных
ограничений $X$ с константами $First(\gamma)$ и $Last(\gamma)$ соответственно.

Пусть даны два, например, префиксных ограничения с константами $\alpha$ и
$\beta$ (для суффиксных --- аналогично). Если $\alpha \in First(\beta)$, то
$\alpha$-ограничение является \textbf{более сильным}. В то же время
$\beta$-ограничение есть \textbf{более слабое} по сравнению с первым. Имеет
смысл хранить в уравнении лишь самые сильные ограничения.


\subsection{Избыточные рестрикции и условия}

В результате некоторых действий краевые рестрикции могут стать неактуальными
(с рестрикциями на пустоту этого не происходит), вследствие чего их можно
удалить из уравнения. Будем называть краевую рестрикцию \textbf{избыточной} в
двух случаях:
\begin{itemize}
  \item участвующей в ней переменной нет в уравнении;
  \item участвующей в ней константы нет в уравнении, а также в правых частях
  условий на константы.
\end{itemize}

Условие на константу также может стать \textbf{избыточным}. Это происходит в
следующих ситуациях:
\begin{itemize}
  \item константа в левой части условия не участвует в уравнении и не является
  $Bound$-элементом какой-либо другой константы;
  \item условие имеет парный тип, обеих констант его правой части нет в
  уравнении и на них нет каких-либо других условий.
\end{itemize}


\subsection{Обработка нетривиальных ограничений}

Нетривиальные ограничения на переменные также могут подвергаться обработке.
Пусть уравнение содержит
\begin{Verbatim}
  t.NonTrivialConstr: (OR t.SuffixRestr t.PrefixRestr).
\end{Verbatim}
Если в уравнении найдётся равное или более сильное в сравнении с
\texttt{(OR t.SuffixRestr)} или \texttt{(OR t.PrefixRestr)} краевое
ограничение, то \texttt{t.NonTrivialConstr} \textbf{выполняется тривиально},
и его можно удалить. Это же происходит и в случае, когда избыточна хотя
бы одна из рестрикций \texttt{t.SuffixRestr} и \texttt{t.PrefixRestr}.

Будем называть префиксную рестрикцию с константой $\alpha \in \Sigma$
\textbf{зависимой} относительно некоторого $\beta \in \Sigma$, если
$\alpha \in First(\beta) \cup \{\beta\}$. В противном случае рестрикция
называется \textbf{независимой}.

Иногда нам потребуется модифицировать нетривиальные ограничения. Например, мы
хотим выполнить \textit{подстановку}
\begin{displaymath}
  X \to X \alpha, \quad X \in \Xi, \quad \alpha \in \Sigma
\end{displaymath}
при наличии такого ограничения с зависимой относительно $\alpha$ рестрикцией.
Мы \textbf{вынуждаем} выполнение второй рестрикции, превращая тем самым
нетривиальное ограничение в тривиальное.


\subsection{Подстановки}

В алгоритме повсеместно требуется выполнять нерекурсивные подстановки
выражений. Определим для этого специальный формат \texttt{t.Subst}:
\begin{Verbatim}
  t.Subst ::= (assign (e.Old) (e.New)),
\end{Verbatim}
где выражение \texttt{e.Old: e.ANY} --- заменяемое, а \texttt{e.New: e.ANY}
--- новое.

Практически всегда подстановка заключается в извлечении у переменной слева или
справа константы и обращении этой переменной в пустое слово. Например,
\begin{displaymath}
  X \to X \alpha, \ Y \to \beta Y, \ Z \to \varepsilon,
  \quad X, Y, Z \in \Xi,
  \quad \alpha, \beta \in \Sigma.
\end{displaymath}
Такие подстановки называются соответственно \textit{суффиксными},
\textit{префиксными} и \textit{пустыми}.

В контексте конкретной задачи подстановки могут быть \textbf{элементарными} и
\textbf{композитными}. Это означает, что для достижения некоторой цели могут
потребоваться одна или несколько одновременно выполняющихся подстановок.


\subsection{Нормальное уравнение}

Назвовём \textbf{сокращением} уравнения удаление всех совпадающих префиксных
и суффиксных элементов его левой и правой частей. Два уравнения будем называть
\textbf{эквивалентными}, если их сокращение производит уравнения с одинаковыми
левыми и правыми частями.

Скажем, что уравнение \textbf{нормальное}, если оно несократимо, не содержит
слабых и тривиально выполняющихся ограничений и избыточных рестрикций и условий.
Также потребуем, чтобы в нормальном уравнении все ограничения были
отсортированы, равно как и показатели степеней \texttt{t.Exp} условий на блок.
В реализации используется быстрая сортировка, принимающая функцию-компаратор.
Определив такие компараторы для ограничений и показателей степеней появляется
возможность эффективно сортировать указанные элементы.

Нормальные уравнения представляют особый интерес для нас. Именно их возращают и
ожидают получить на вход функции \texttt{Pick}, \texttt{SubstIndex},
\texttt{PairComp} и \texttt{BlockComp}.



\section{Функция \texttt{Pick}} \label{pick}

Скажем, что решение уравнения \textbf{неминимальное}, если его левая и правая
части состоят из непустых переменных и только них.

Функция \texttt{Pick} принимает номер уравнения \texttt{s.Number: s.NUMBER}
и сами уравнения \texttt{e.Eqs: t.Eq+}. Все переменные уравнения под номером
\texttt{s.Number}, для которых возможна подстановка в пустое слово, обращает в
$\varepsilon$ и возвращает
\begin{itemize}
  \item \texttt{Success}, если новое уравнение эквивалентно уравнению
  $\varepsilon = \varepsilon$;
  \item \texttt{NotMinimal}, если решение такого уравнения неминимальное;
  \item новое нормальное уравнение в остальных случаях.
\end{itemize}

\texttt{Pick} имеет довольно простую реализацию. Из множества всех переменных
уравнения вычитаются непустые, для оставшихся же генерируются и выполняются
подстановки в пустое слово. Если получившееся уравнение эквивалентно
$\varepsilon = \varepsilon$, возвращаем \texttt{Success}. В противном случае
получаем множество констант нового уравнения. Если это множество пусто,
возвращаем \texttt{NotMinimal}, иначе --- получившееся нормализованное
уравнение.



\section{Функция \texttt{SubstIndex}} \label{substIndex}

Функция \texttt{SubstIndex} принимает индекс \texttt{s.Index: s.WORD},
показатели \texttt{e.Exps: t.Exp+}, уравнение \texttt{t.Eq} и выполянет
подстановку показателей на место данного индекса.

Для всякого условия на блок с показателем \texttt{(s.Index s.NUMBER)}
производится замена этого показателя на множество \texttt{e.Exps},
каждый элемент которого домножен на постоянную \texttt{s.NUMBER}.
Обычно после этого шага порядок показателей нарушается --- их
нужно отсортировать.

В результате подстановки может получиться условие вида
\begin{Verbatim}
  t.Cond: (t.Const is (t.BlockConst (const 0))).
\end{Verbatim}
Такое условие \textit{коллапсирует}, так как коллапсирует содержавшийся в нём
блок. Нам полезно на месте генерировать подстановки констант из левых частей
таких условий в $\varepsilon$: позже мы осуществим эти подстановки в левой и
правой частях уравнения.

Также мы могли получить условия с разными левыми, но одинаковыми правыми
частями:
\begin{Verbatim}
  t.Cond1: (t.Const1 is (t.BlockConst e.Exps (const s.NUMBER))),
  t.Cond2: (t.Const2 is (t.BlockConst e.Exps (const s.NUMBER))).
\end{Verbatim}
В таком случае мы сохраняем лишь одно условие (в реализации --- с
лексикографически наименьшей константой), например, \texttt{t.Cond1}, и
генерируем замену константы второго условия \texttt{t.Const2} на
\texttt{t.Const1}.

Теперь выполняем в уравнении все сгенерированные подстановки (констант
коллапсировавших и заменённых условий). Остаётся лишь нормализовать полученное
уравнение.



\section{Функция \texttt{PairComp}} \label{pairComp}


\subsection{Вхождения сжимаемой пары} \label{pair-occurency}

Рассмотрим возможности появления пары $\alpha \beta \in \Sigma^+ $ в
уравнении. Пусть одна из его частей представляется как 
\begin{equation}
  \Phi \alpha \beta \Psi, \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*.
\end{equation}
Здесь получаем \textbf{явное} вхождение исходной пары. Если часть уравнения
имеет вид
\begin{equation} \label{pair-occurency:2}
  \Phi X \beta \Psi, \quad X \in \Xi, \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*,
\end{equation}
мы можем рассмотреть случай, когда решение $X$ оканчивается на $\alpha$, т.е.
$X = X\alpha$. Выполнив подстановку $X \to X\alpha$ (если это возможно)
получим новое явное вхождение пары $\alpha \beta$. Поэтому нам интересна
ситуация \eqref{pair-occurency:2}. Будем называть такое вхождение пары
\textbf{перекрёстным}.

Случай
\begin{equation} \label{pair-occurency:3}
  \Phi \alpha Y \Psi, \quad Y \in \Xi, \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*
\end{equation}
симметричен предыдущему: имеем перекрёстное вхождение пары $\alpha \beta$ и
можем получить явное, выполнив подстановку $Y \to \beta Y$.

Наконец, часть уравнения может представляться в виде
\begin{equation} \label{pair-occurency:4}
  \Phi X Y \Psi, \quad X, Y \in \Xi, \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*.
\end{equation}
В таком случае новое явное вхождение появляется (при отсутствии соответствующих
ограничений) с выполненными одновременно подстановками $X \to X \alpha$ и
$Y \to \beta Y$.

Пара $\alpha \beta$ также может входить в уравнение \textbf{неявно}, не являясь
началом или концом решения, а находясь полностью внтури него. Такая
ситуация в силу неминимальности нам неинтересна.


\subsection{Существенные подстановки} \label{essential-substs}

Обратим внимание на случаи \eqref{pair-occurency:2}-\eqref{pair-occurency:4}
раздела \ref{pair-occurency}. Здесь краевые подстановки в своём контексте
порождают новые явные вхождения в уравнение пары $\alpha \beta$, поэтому они
называются \textbf{существенными}. Существенные элементарные и композитные
подстановки включают одну и две подстановки соответственно. Например,
подстановки в \eqref{pair-occurency:2} и \eqref{pair-occurency:3} являются
существенными элементарными, а в \eqref{pair-occurency:4} --- существенной
композитной.

В реализации нам потребуется понятие \textbf{специальной} подстановки: таковыми
будем называть существенные элементарные подстановки, являющиеся частью
какой-либо существенной композитной подстановки.

Описанные выше подстановки являются \textit{непустыми}, но и \textit{пустые}
подстановки могут порождать новые явные пары, также называясь в этом случае
существенными. Пусть часть уравнения представляется в виде
\begin{equation} \label{emptySubst:1}
  \Phi \alpha \Omega \beta \Psi, \quad \Omega \in \Xi^+, \quad \Phi, \Psi \in
  (\Sigma \cup \Xi)^*,
\end{equation}
где хотя бы одна переменная в $\Omega$ может быть пуста. Пусть такой переменной
будет $W \in \Xi$. Если максимальный блок $W^i$, $i \in \mathbb{N}$, следует
непосредственно за $\alpha$, обратив переменную в $\varepsilon$ мы получим или
новую явную пару $\alpha \beta$, или новую перекрёстную пару при соседстве
$\alpha$ с новой переменной, следующей прямо за $W^i$. Получаем симметричную
ситуацию, если $W^i$ непосредственно предшествует $\beta$. Если же $W^i$
находится внутри $\Omega$, подстановка в пустое слово даст новое соседство двух
переменных, следовательно --- новое перекрёстное вхождение, где явная пара
может быть порождена существенной композитной подстановкой.

Во всех случаях имеет смысл совершать подстановку $W \to \varepsilon$. Мы
приходим к следующей \textbf{лемме}: всякое подмножество существенной
композиции пустых подстановок существенно.

Аналогично \eqref{emptySubst:1} разбираются ситуации
\begin{equation}
  \Phi X \Omega \beta \Psi, \quad X \in \Xi, \quad \Omega \in (\Xi / X)^+,
  \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*,
\end{equation}
\begin{equation}
  \Phi \alpha \Omega Y \Psi, \quad Y \in \Xi, \quad \Omega \in (\Xi / Y)^+,
  \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*,
\end{equation}
\begin{equation}
  \Phi X \Omega Y \Psi, \quad X, Y \in \Xi, \quad \Omega \in (\Xi / X / Y)^+,
  \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*,
\end{equation}
Важно, чтобы среди $\Omega$ была хотя бы одна переменная, для которой возможна
пустая подстановка.


\subsection{Опции \texttt{PairComp}} \label{pair-option}

Для данного уравнения может обнаружиться множество пустых и непустых
существенных подстановок. Вообще, не любая их комбинация ведёт к решению.
Необходимо перебрать их всевозможные сочетания и уже среди них искать
успешные.

\textbf{Опция} уравнения --- легковесная абстракция для представления такого
набора. В \texttt{PairComp} опция представляется типом \texttt{t.PairOption:}
\begin{Verbatim}
  t.PairOption ::= ((e.Substs) (e.Constrs)).
\end{Verbatim}
Здесь \texttt{e.Substs} хранит определённую комбинацию подстановок, а
\texttt{e.Constrs} --- накладываемые ограничения при этих подстановках. В
совокупности ограничения могут быть противоречивы --- такие опции отбрасываются
сразу, не применяясь к уравнению. Остальные же \textit{нормализуются} и
производят новые уравнения. Нормализация \texttt{t.PairOption} означает
удаление дубликатов, тривиально выполняющихся ограничений и конфликтующих
рестрикций. Ограничения нормальной опции \textit{модифицируются}: при
префиксных подстановках удаляются независимые (зависимых на этом этапе быть не
может --- противоречие) префиксные и пустые ограничения, при суффиксных ---
симметрично. Наконец, к ограничениям опции прибавляются ограничения уравнения,
чтобы в дальнейшем их уже не пришлось как-либо изменять.


\subsection{Реализация \texttt{PairComp}}

Функция принимает константу для замены \texttt{t.ReplConst}, элементы сжимаемой
пары \texttt{t.Const1} и \texttt{t.Const2}, а также уравнение \texttt{t.Eq}.
\texttt{PairComp} генерирует новую константу для замены и новые уравнения,
выполняя различные комбинаций существенных пустых и непустых подстановок
исходного уравнения \texttt{t.Eq}.

В начале рекурсивно генерируются ветви с выполняющимися и невыполняющимися
существенными пустыми подстановками. Подстановки отбираются по одной, как
описано в разделе \ref{essential-substs}. Для первой ветви сразу удаляются
избыточные ограничения, возникшие с подстановкой переменной в $\varepsilon$,
а к ограничениям второй ветви прибавляется непустота переменной.

Остановимся на какой-нибудь ветви. Как только на ней заканчиваются возможные
существенные пустые подстановки, начинается поиск всех существенных непустых
--- элементарных и композитных. Они отбираются с учётом существующих краевых
ограничений, поэтому на выходе получаем только возможные подстановки. Среди
них удаляются дубликаты, а также определяются специальные подстановки.

Теперь можно генерировать первичные наборы опций, которые в дальнейшем будут
декартово переменожаться. Говоря \textit{подстановка выполняется} будем
подразумевать осуществление данной подстановки без накладываемых ограничений.
Говоря, что \textit{подстановка не выполняется}, будем иметь в виду невыполнение
подстановки с добавлением соответствующего ограничения.

Для всякой элементарной неспециальной подстановки генерируется
\textbf{элементарный набор} из двух опций: в одной из них подстановка
выполняется, а в другой --- нет.

Для каждой композитной подстановки в зависимости от числа составляющих её
специальных подстановок производится один из трёх \textbf{композитных наборов}.
\begin{enumerate}
  \item \textit{Обе} подстановки специальные. Набор содержит четыре опции:
  в первой выполняются обе подстановки, во второй выполняется одна и не
  выполняется другая, в третьей --- наоборот, а в четвёртой не выполняется
  ни одна из подстановок.
  
\item \textit{Одна} подстановка специальная, другая --- нет. В наборе
  три опции: в первой выполняются обе подстановки, во второй выполняется
  специальная и не выполняется оставшаяся, в третьей просто не выполняется
  специальная.
    
\item \textit{Ни одна} из подстановок не является специальной. Набор
  состаляют две опции. В первой выполняются обе подстановки, а во второй не
  выполняется или одна, или другая. \textit{Этот набор единственный во
  всей программе порождает нетривиальные ограничения}.
\end{enumerate}

Производится декартово произведение полученных наборов. Пока есть два и более
таких множества, берётся пара наборов, и их опции переменожаются. Результат
--- уже одно, а не два множества --- возвращается в исходное семейство, и
процедура повторяется.

\textit{Мы получили опции уравнения такими, какими мы определяли их в разделе
\emph{\ref{pair-option}}}. Нужно попытаться нормализовать эти опции: некоторые
из них, возможно, будут удалены как противоречивые. Оставшиеся же
дорабатываются как описывается в упомянутом разделе.

Наконец, опции применяются к уравнению. Если к этому моменту нет ни одной опции
(изначально не было существенных непустых подстановок или все опции оказались
противоречивы), искусственно применяется \textit{пустая опция} вида
\texttt{((/* no substs */) (/* no constrs */))}. Для каждой опции все её
подстановки применяются к уравнению. Образовавшиеся явные пары сжимаются.
Ограничения полученного уравнения подменяются ограничениями опции, и результат
нормализуется.



\section{Функция \texttt{BlockComp}} \label{blockComp}


\subsection{Сжатие переменной в блок} \label{block-comp}

Предположим, что в уравнении нет тривиальных ограничений на его переменную $X
\in \Xi$ (\textit{нетривиальные ограничения не обрабатываются}). При сжатии $X$
в блок $\alpha \in \Sigma$ необходимо рассмотреть два случая:
\begin{itemize}
  \item переменная \textit{коллапсирует} в блок:
  \begin{equation} \label{block:collapsed}
    X \to \alpha^i, \ i \in \mathbb{N} \cup \{ 0 \}.
  \end{equation}

  \item происходит извлечение максимальных префиксных и суффиксных блоков у
  переменной:
  \begin{equation} \label{block:extracted}
    X \to \alpha^i X \alpha^j, \ i, j \in \mathbb{N} \cup \{ 0 \}.
  \end{equation}
  Теперь $X$ не может начинаться или кончаться на $\alpha$ в силу
  максимальности извлечённых блоков, а также не может быть пустым (иначе
  переменная сжималась бы в блок)
  \begin{equation} \label{block:constraints}
    X \ne \alpha X, \quad X \ne X \alpha, \quad X \ne \varepsilon.
  \end{equation}
\end{itemize}

Допустим, в уравнении есть префиксные ограничения на $X$, независимые
относительно $\alpha$ (суффиксные ограничения здесь и далее обрабатываются
симметричным образом). Случай \eqref{block:extracted} теперь ветвится:
\begin{itemize}
  \item Префиксный блок пуст, извлекается только суффиксный:
  \begin{displaymath}
    X \to X \alpha^j, \ j \in \mathbb{N} \cup \{ 0 \}.
  \end{displaymath}
  Исходные ограничения сохраняются с присоединением ограничений
  \eqref{block:constraints}.
  
  \item Префиксный блок \textit{не} пуст:
  \begin{displaymath}
    X \to \alpha^i X \alpha^j, \ i, j \in \mathbb{N} \cup \{ 0 \}.
  \end{displaymath}

  Исходные ограничения удаляются, а \eqref{block:constraints} ---
  добавляются.
\end{itemize}

Пусть вместе с присутствующими или отсутствующими независимыми префиксными
ограничениями на $X$ переменная также непуста. Это влияет только на сжатие
в блок \eqref{block:collapsed}: подстановка заменяется на
\begin{equation} \label{block:non-empty-collapsed}
  X \to \alpha^{i + 1}, \ i \in \mathbb{N} \cup \{ 0 \},
\end{equation}
а ограничения на переменную, если были в уравнении, удаляются.

Теперь рассмотрим случай, когда уравнение содержит только префиксные
ограничения --- зависимые и, возможно, независимые. Сжатие в блок
\eqref{block:collapsed} становится \textit{невозможным}; оно заменяется на
пустую подстановку $X \to \varepsilon$ с удалением всех ограничений. Извлечение
префиксного блока в \eqref{block:extracted} также незаконно, поэтому
извлекается только суффиксный:
\begin{equation} \label{block:dependent-prefix}
  X \to X \alpha^j, \ j \in \mathbb{N} \cup \{ 0 \};
\end{equation}
прежние ограничения сохраняются, а из новых \eqref{block:constraints}
добавляются только $X \ne \varepsilon$ и $X \ne X \alpha$, так как $X \ne
\alpha X$ равно или слабее по силе существующих зависимых префиксных
ограничений.

Наконец, если $X$ ещё и не пуст, коллапсирование в $\varepsilon$ вообще
блокируется, и остаётся только извлечение \eqref{block:dependent-prefix}.

В Рефале сжатая в блок константа, например, \texttt{('A' 0)} при таких
подстановках имеет вид
\begin{Verbatim}
  (('A' 0) Index (const 0)).
\end{Verbatim}
Здесь \texttt{Index} есть переменная пока что \textit{безымянного} показателя степени. В будущем,
как станут известны все такие безымянные блоки уравнения, на место
\texttt{Index} встанет конкретный переменный показатель: например,
\texttt{(i1 1)}.


\subsection{Опции \texttt{BlockComp}} \label{block-option}

Опция \texttt{t.BlockOption}, как и \texttt{t.PairOption}, хранит комбинации
подстановок и модифицируемые ограничения, с применением которых исходное
уравнение порождает новые. Ограничения \texttt{block}-опции сразу будем
делить на \textit{добавляемые} к уравнению и \textit{исключаемые} из него. Так
делать, вообще, необязательно, но нынешняя реализация строится на этом подходе.
Таким образом, \texttt{t.BlockOption} представляется в виде
\begin{Verbatim}
  ((e.Substs) (e.AddedConstrs) (e.ExcludedConstrs)). 
\end{Verbatim}

В отличие от набора \texttt{t.PairOption}, декартово произведение
\texttt{block}-опций всегда совместимо, поскольку мы никак не обрабатываем
нетривиальные ограничения (а если бы даже обрабатывали, недопустима ситуация
с двумя зависимыми относительно сжимаемой константы рестрикциями, содержащимися
в одном ограничении --- т.е. мы всегда сможем выбрать \textit{удовлетворяющую}
нас рестрикцию). Тем не менее, в таких наборах всё так же нужно удалять
тривиально выполняющиеся и избыточные в связи с коллапсированием переменной в
блок или $\varepsilon$ ограничения.

Наконец, к изменённым ограничениям опции прибавляются ограничения уравнения
(для заменещения в дальнейшем).


\subsection{Реализация \texttt{BlockComp}}

Функция принимает константу для сжатия \texttt{t.BlockConst}, константу
и индекс \texttt{t.NewConst} и \texttt{s.NewIndex} соответственно для введения
условий и уравнение \texttt{t.Eq}.

Для каждой переменной уравнения генерируется первичный набор опций по правилам,
описанным в разделах \ref{block-comp} и \ref{block-option}. Число опций в
наборе варьируется от одной пустой (если зависимые и префиксные, и суффиксные
ограничения, а переменная непуста) до целых пяти в случае, когда
префиксные и суффиксные ограничения независимы (здесь одна опция ---
коллапсирование переменной, другие четыре есть результат декартова произведения
$2 \times 2$ опций с извлечением префиксных и суффиксных блоков).

Производится декартово произведение таких первичных наборов. Полученные опции
нормализуются и применяются к уравнению.

После применения подстановок опции части уравнения содержат безымянные блоки,
описанные в конце раздела \ref{block-comp}. Такие стоящие рядом друг с другом
или сжимаемой константой блоки \textit{объединяются}, образуя новую степень
\texttt{t.BlockConst}. В частности, две стоящие рядом исходные константы
преобразуются в единый блок-квадрат.

После объединения всех указанных блоков безымянные индексы \texttt{Index}
в лексикографическом порядке заменяются на конкретные переменные показатели
степени. Полученные блоки обозначаются и переносятся в условия на константы.

Наконец, функция возвращает неиспользованные константу и индекс, а также
нормализованное получившееся уравнение.



\section{Тестирование}

Реализация корректно отрабатывает на многих наборах входных данных. В разделе
приведены некоторые unit-тесты, написанные при разработке каждой из четырёх
функций.


\subsection{Функция \texttt{Pick}}

На вход подаются слудующие уравнения \mir{e.Eqs}:
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
(
  (
    AreEqual
    ((Var 'X') ('A' 0))
    ((Var 'Y') ('B' 0) (Var 'Y'))
  )
  (/* no constrs */)
  (/* no conds */)
)
(
  (
    AreEqual
    (('A' 0) (Var 'X') ('A' 0))
    ((Var 'Y') ('A' 0) ('A' 0) (Var 'Y'))
  )
  (
    (OR (not empty (Var 'X')))
    (OR (not ('A' 0) starts (Var 'X')) (not ('B' 0) ends (Var 'X')))
  )
  (/* no conds */)
)
(
  (
    AreEqual
    ((Var 'X'))
    ((Var 'Y'))
  )
  (
    (OR (not empty (Var 'X')))
  )
  (/* no conds */)
)
(
  (
    AreEqual
    ((Var 'X') ('A' 0))
    (('A' 0) (Var 'Y'))
  )
  (
    (OR (not ('A' 0) ends (Var 'X')))
  )
  (/* no conds */)
)
\end{minted}
В результате вызовов \mir{<Pick 1 e.Eqs>} и \mir{<Pick 2 e.Eqs>} получаем 
преобразованные уравнения, при \mir{<Pick 3 e.Eqs>} --- \texttt{NotMinimal},
а \mir{<Pick 4 e.Eqs>} возвращает \texttt{Success}.


\subsection{Функция \texttt{SubstIndex}}

Замена индекса \mir{i1} на \mir{((i2 2) (const 2))} в уравнении
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
(
  (
    AreEqual
    (('A' 2))
    (('A' 1) (Var 'X') ('A' 1))
  )
  (
    (OR (not empty (Var 'X')))
  )
  (
    (('A' 1) is (('A' 0) (i1 1) (const 0)))
    (('A' 2) is (('A' 0) (i2 2) (const 2)))
  )
)
\end{minted}
производит уравнение
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
(
  (
    AreEqual
    (/* empty */)
    ((Var 'X') ('A' 1))
  )
  (
    (OR (not empty (Var 'X')))
  )
  (
    (('A' 1) is (('A' 0) (i2 2) (const 2)))
  )
)
\end{minted}
А, например, композиция функций \mir{<SubstIndex i4 ((i1 3) (const 1)) t.Eq>}
и \mir{<SubstIndex i1 ((i2 2) (i3 1) (const 0)) t.Eq>}, применённых к такому
уравнению \mir{t.Eq}
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
(
  (
    AreEqual
    (('A' 3) ('B' 0) (Var 'X') ('A' 3) (Var 'Y'))
    (('A' 2) ('B' 0) (Var 'X') (Var 'Z') ('A' 2))
  )
  (/* no constrs */)
  (
    (('A' 1) is (('A' 0) (i1 3) (const 1)))
    (('A' 2) is (('A' 0) (i2 6) (i3 3) (const 1)))
    (('A' 3) is (('A' 0) (i4 1) (const 0)))
  )
)
\end{minted}
возвращает
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
(
  (
    AreEqual
    (('A' 2) (Var 'Y'))
    ((Var 'Z') ('A' 2))
  )
  (/* no constrs */)
  (
    (('A' 2) is (('A' 0) (i2 6) (i3 3) (const 1)))
  )
)
\end{minted}


\subsection{Функция \texttt{PairComp}}

Сжатие пары \mir{('A' 1) ('B' 0)} новой константой \mir{('B' 1)} в уравнении
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
(
  (
    AreEqual
    (('A' 1) ('B' 0) ('C' 0) (Var 'X') ('B' 0))
    ((Var 'Y') (Var 'Z') ('B' 0) ('A' 1) (Var 'X'))
  )
  (
    (OR (not empty (Var 'Z')))
    (OR (not ('C' 0) ends (Var 'Y')))
    (OR (not ('A' 1) ends (Var 'X')) (not ('B' 0) starts (Var 'X')))
  )
  ((('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1))))
)
\end{minted}
возвращает новую константу \mir{('C' 1)} и производит 6 уравнений:
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
(
  /* X = A1 X, Z = Z A1, X != B0 X */
  (
    AreEqual
    (('B' 1) ('C' 0) (Var 'X') ('B' 1))
    ((Var 'Y') (Var 'Z') ('B' 1) ('A' 1) (Var 'X') ('A' 1))
  )
  (
    (OR (not ('C' 0) ends (Var 'Y')))
    (OR (not ('B' 0) starts (Var 'X')))
  )
  (
    (('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1)))
    (('B' 1) is (('A' 1) (const 1)) (('B' 0) (const 1)))
  )
)
(
  /* X = A1 X, Z != Z A1, X != B0 X */
  (
    AreEqual
    (('B' 1) ('C' 0) (Var 'X') ('B' 1))
    ((Var 'Y') (Var 'Z') ('B' 0) ('A' 1) (Var 'X') ('A' 1))
  )
  (
    (OR (not empty (Var 'Z')))
    (OR (not ('C' 0) ends (Var 'Y')))
    (OR (not ('A' 1) ends (Var 'Z')))
    (OR (not ('B' 0) starts (Var 'X')))
  )
  (
    (('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1)))
    (('B' 1) is (('A' 1) (const 1)) (('B' 0) (const 1)))
  )
)
(
  /* X != A1 X, Z = Z A1, X = B0 X */
  (
    AreEqual
    (('B' 1) ('C' 0) ('B' 0) (Var 'X') ('B' 0))
    ((Var 'Y') (Var 'Z') ('B' 1) ('B' 1) (Var 'X'))
  )
  (
    (OR (not ('A' 1) ends (Var 'X')))
    (OR (not ('C' 0) ends (Var 'Y')))
  )
  (
    (('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1)))
    (('B' 1) is (('A' 1) (const 1)) (('B' 0) (const 1)))
  )
)
(
  /* X != A1 X, Z = Z A1, X != B0 X */
  (
    AreEqual
    (('B' 1) ('C' 0) (Var 'X') ('B' 0))
    ((Var 'Y') (Var 'Z') ('B' 1) ('A' 1) (Var 'X'))
  )
  (
    (OR (not ('A' 1) ends (Var 'X')))
    (OR (not ('C' 0) ends (Var 'Y')))
    (OR (not ('B' 0) starts (Var 'X')))
  )
  (
    (('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1)))
    (('B' 1) is (('A' 1) (const 1)) (('B' 0) (const 1)))
  )
)
(
  /* X != A1 X, Z != Z A1, X = B0 X */
  (
    AreEqual
    (('B' 1) ('C' 0) ('B' 0) (Var 'X') ('B' 0))
    ((Var 'Y') (Var 'Z') ('B' 0) ('B' 1) (Var 'X'))
  )
  (
    (OR (not empty (Var 'Z')))
    (OR (not ('A' 1) ends (Var 'X')))
    (OR (not ('C' 0) ends (Var 'Y')))
    (OR (not ('A' 1) ends (Var 'Z')))
  )
  (
    (('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1)))
    (('B' 1) is (('A' 1) (const 1)) (('B' 0) (const 1)))
  )
)
(
  /* X != A1 X, Z != Z A1, X != B0 X */
  (
    AreEqual
    (('B' 1) ('C' 0) (Var 'X') ('B' 0))
    ((Var 'Y') (Var 'Z') ('B' 0) ('A' 1) (Var 'X'))
  )
  (
    (OR (not empty (Var 'Z')))
    (OR (not ('A' 1) ends (Var 'X')))
    (OR (not ('C' 0) ends (Var 'Y')))
    (OR (not ('A' 1) ends (Var 'Z')))
    (OR (not ('B' 0) starts (Var 'X')))
  )
  (
    (('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1)))
    (('B' 1) is (('A' 1) (const 1)) (('B' 0) (const 1)))
  )
)
\end{minted}


\subsection{Функция \texttt{BlockComp}}

Сжатие в блок составной константы \mir{('A' 1)} уравнения
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
(
  (
    AreEqual
    (('A' 1) (Var 'X') (Var 'Y') ('B' 0))
    ((Var 'X') ('C' 0) ('A' 1) (Var 'Z'))
  )
  (
    (OR (not empty (Var 'Y')))
    (OR (not empty (Var 'Z')))
    (OR (not ('C' 0) ends (Var 'X')))
    (OR (not ('B' 0) ends (Var 'Y')))
    (OR (not ('A' 1) starts (Var 'X')))
  )
  ((('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1))))
)
\end{minted}
с введением константы \mir{('B' 1)} и индекса \mir{i1} производит 6 новых
уравнений с новыми константами и индексами:
\begin{minted}[breaklines, fontsize=\small]{Lexer.py:RefalLexer -x}
/* X = empty, Y = A1^i Y, Z = A1^(j+1) */
(
  ('D' 1) i3
  (
    (
      AreEqual
      (('B' 1) (Var 'Y') ('B' 0))
      (('C' 0) ('C' 1))
    )
    (
      (OR (not empty (Var 'Y')))
      (OR (not ('B' 0) ends (Var 'Y')))
      (OR (not ('A' 1) starts (Var 'Y')))
    )
    (
      (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
      (('B' 1) is (('A' 1) (i1 1) (const 1)))
      (('C' 1) is (('A' 1) (i2 1) (const 2)))
    )
  )
)
/* X = empty, Y = A1^i Y, Z = A1^j Z A1^k */
(
  ('E' 1) i4
  (
    (
      AreEqual
      (('B' 1) (Var 'Y') ('B' 0))
      (('C' 0) ('C' 1) (Var 'Z') ('D' 1))
    )
    (
      (OR (not empty (Var 'Y')))
      (OR (not empty (Var 'Z')))
      (OR (not ('B' 0) ends (Var 'Y')))
      (OR (not ('A' 1) ends (Var 'Z')))
      (OR (not ('A' 1) starts (Var 'Y')))
      (OR (not ('A' 1) starts (Var 'Z')))
    )
    (
      (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
      (('B' 1) is (('A' 1) (i1 1) (const 1)))
      (('C' 1) is (('A' 1) (i2 1) (const 1)))
      (('D' 1) is (('A' 1) (i3 1) (const 0)))
    )
  )
)
/* X = X, Y = A1^i Y, Z = A1^(j+1) */
(
  ('D' 1) i3
  (
    (
      AreEqual
      (('A' 1) (Var 'X') ('B' 1) (Var 'Y') ('B' 0))
      ((Var 'X') ('C' 0) ('C' 1))
    )
    (
      (OR (not empty (Var 'X')))
      (OR (not empty (Var 'Y')))
      (OR (not ('C' 0) ends (Var 'X')))
      (OR (not ('A' 1) ends (Var 'X')))
      (OR (not ('B' 0) ends (Var 'Y')))
      (OR (not ('A' 1) starts (Var 'X')))
      (OR (not ('A' 1) starts (Var 'Y')))
    )
    (
      (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
      (('B' 1) is (('A' 1) (i1 1) (const 0)))
      (('C' 1) is (('A' 1) (i2 1) (const 2)))
    )
  )
)
/* X = X, Y = A1^i Y, Z = A1^j Z A1^k) */
(
  ('E' 1) i4
  (
    (
      AreEqual
      (('A' 1) (Var 'X') ('B' 1) (Var 'Y') ('B' 0))
      ((Var 'X') ('C' 0) ('C' 1) (Var 'Z') ('D' 1))
    )
    (
      (OR (not empty (Var 'X')))
      (OR (not empty (Var 'Y')))
      (OR (not empty (Var 'Z')))
      (OR (not ('C' 0) ends (Var 'X')))
      (OR (not ('A' 1) ends (Var 'X')))
      (OR (not ('B' 0) ends (Var 'Y')))
      (OR (not ('A' 1) ends (Var 'Z')))
      (OR (not ('A' 1) starts (Var 'X')))
      (OR (not ('A' 1) starts (Var 'Y')))
      (OR (not ('A' 1) starts (Var 'Z')))
    )
    (
      (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
      (('B' 1) is (('A' 1) (i1 1) (const 0)))
      (('C' 1) is (('A' 1) (i2 1) (const 1)))
      (('D' 1) is (('A' 1) (i3 1) (const 0)))
    )
  )
)
/* X = X A1^i, Y = A1^j Y, Z = A1^(k+1) */
(
  ('E' 1) i5
  (
    (
      AreEqual
      (('A' 1) (Var 'X') ('B' 1) (Var 'Y') ('B' 0))
      ((Var 'X') ('C' 1) ('C' 0) ('D' 1))
    )
    (
      (OR (not empty (Var 'X')))
      (OR (not empty (Var 'Y')))
      (OR (not ('A' 1) ends (Var 'X')))
      (OR (not ('B' 0) ends (Var 'Y')))
      (OR (not ('A' 1) starts (Var 'X')))
      (OR (not ('A' 1) starts (Var 'Y')))
    )
    (
      (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
      (('B' 1) is (('A' 1) (i1 1) (i2 1) (const 0)))
      (('C' 1) is (('A' 1) (i3 1) (const 0)))
      (('D' 1) is (('A' 1) (i4 1) (const 2)))
    )
  )
)
/* X = X A1^i, Y = A1^j Y, Z = A1^k Z A1^l */
(
  ('F' 1) i6
  (
    (
      AreEqual
      (('A' 1) (Var 'X') ('B' 1) (Var 'Y') ('B' 0))
      ((Var 'X') ('C' 1) ('C' 0) ('D' 1) (Var 'Z') ('E' 1))
    )
    (
      (OR (not empty (Var 'X')))
      (OR (not empty (Var 'Y')))
      (OR (not empty (Var 'Z')))
      (OR (not ('A' 1) ends (Var 'X')))
      (OR (not ('B' 0) ends (Var 'Y')))
      (OR (not ('A' 1) ends (Var 'Z')))
      (OR (not ('A' 1) starts (Var 'X')))
      (OR (not ('A' 1) starts (Var 'Y')))
      (OR (not ('A' 1) starts (Var 'Z')))
    )
    (
      (('A' 1) is (('A' 0) (const 1)) (('B' 0) (const 1)))
      (('B' 1) is (('A' 1) (i1 1) (i2 1) (const 0)))
      (('C' 1) is (('A' 1) (i3 1) (const 0)))
      (('D' 1) is (('A' 1) (i4 1) (const 1)))
      (('E' 1) is (('A' 1) (i5 1) (const 0)))
    )
  )
)
\end{minted}



\section{Листинги} \label{code}

В силу большого объёма кода программы (около 2500 строк) в раздел включена
лишь часть реализации основных четырёх функций. Тем не менее, формат и
назначение невключённых, кажется, угадывается по названию и контексту
использования.

\subsection{Функция \texttt{Pick}}

\begin{minted}[breaklines, linenos, fontsize=\small]{Lexer.py:RefalLexer -x}
/*
  <Pick s.NUMBER e.Eqs>
    == Success
    == NotMinimal
    == t.Eq
*/
Pick {
  s.Number t.Eq e.RestEqs
    , s.Number : {
      1, t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
        , <MapCompose
            ((GetVars (e.LHS)) (GetVars (e.RHS))) (/* empty */)
          > : (e.Vars)
        , <SubtractSets
            (e.Vars) (<GetNonEmptyVars e.Constrs>)
          > : (e.EmptyVars)
        , <MapCall
            Revert
            (GenSubst (/* empty */))
            <MapCall Plain Wrap e.EmptyVars>
          > : e.Substs
        , <MapCall
            Curry
            (Subst (e.Substs))
            (e.LHS) (e.RHS)
          > : {
          (e.Elems) (e.Elems) = Success;

          (e.NewLHS) (e.NewRHS)
            , <MapCompose
                ((GetConsts (e.NewLHS)) (GetConsts (e.NewRHS)))
                (/* empty */)
              > : {
              (/* no consts */) = NotMinimal;

              (e.SomeConsts)
                , <MapCompose
                    (
                      <MapCall
                        Curry
                        (Wrap CleanUpConstrs)
                        e.Substs
                      >
                    )
                    (e.Constrs)
                  > : (e.NewConstrs)
                = (
                    (AreEqual (e.NewLHS) (e.NewRHS))
                    (e.NewConstrs) (e.Conds)
                  );
            };
        };

      s.Other = <Pick <Sub s.Number 1> e.RestEqs>;
    };
}
\end{minted}


\subsection{Функция \texttt{SubstIndex}}

\begin{minted}[breaklines, linenos, fontsize=\small]{Lexer.py:RefalLexer -x}
/*
  <SubstIndex s.Index (e.Exps) t.Eq> == t.NewEq
*/
SubstIndex {
  s.Index (e.Exps) ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , <SubstExpsToConds
        s.Index (e.Exps) (e.Conds) (/* empty */) (/* empty */)
      > : (e.ReplacedConds) (e.CollapsedConstsSubsts)
    , <ReplaceRepeatedConds
        (e.ReplacedConds) (/* empty */)
      > : (e.UniqueConds) (e.RepeatedConstsSubsts)
    , <MapCall
        Curry
        (Subst (e.CollapsedConstsSubsts e.RepeatedConstsSubsts))
        (e.LHS) (e.RHS)
      > : (e.ReplacedLHS) (e.ReplacedRHS)
    = <NormalizeEq
        (
          (AreEqual (e.ReplacedLHS) (e.ReplacedRHS))
          (e.Constrs) (e.UniqueConds)
        )
      >;
}

/*
  <SubstExpsToConds
    s.Index (e.Exps) (e.Conds) (e.ProcessedConds) (e.Substs)
  >
    == (e.ProcessedConds) (e.Substs)
*/
SubstExpsToConds {
  s.Index (e.Exps) (e.Conds) (e.ProcessedConds) (e.Substs)
    , e.Conds : {
      e.L (t.Const is t.Block) e.R
        , <SubstExpsToBlock s.Index (e.Exps) t.Block> : {
          /* block collapsed */
            = <SubstExpsToConds
                s.Index (e.Exps) (e.R) (e.ProcessedConds e.L)
                (e.Substs <GenSubst (t.Const) (/* empty */)>)
              >;
          
          t.NewBlock
            = <SubstExpsToConds
                s.Index (e.Exps) (e.R)
                (e.ProcessedConds e.L (t.Const is t.NewBlock)) (e.Substs)
              >;
        };

      e.Other = (e.ProcessedConds e.Conds) (e.Substs);
    };
}

/*
  <SubstExpsToBlock s.Index (e.Exps) t.Block>
    == t.NewBlock
    == empty
*/
SubstExpsToBlock {
  s.Index (e.Exps) (t.BlockConst e.OldExps)
    , e.OldExps : {
      e.L (s.Index s.Multiplier) e.R
        , <SumUpExps
            e.L <MapCall Revert (MulExp s.Multiplier) e.Exps> e.R
          > : {
          (const 0) = /* empty */;

          e.ReplacedExps (const s.Number)
            , <QuickSort IsLess-Exp e.ReplacedExps> : e.SortedExps
            = (t.BlockConst e.SortedExps (const s.Number));
        };

      e.Other = (t.BlockConst e.OldExps);
    };
}

/*
  <ReplaceRepeatedConds (e.Conds) (e.Substs)>
    == (e.UniqueConds) (e.Substs)
*/
ReplaceRepeatedConds {
  (e.Conds) (e.Substs)
    , e.Conds : {
      e.L (t.Const1 is t.Block) e.M (t.Const2 is t.Block) e.R
        = <ReplaceRepeatedConds
            (e.L (t.Const1 is t.Block) e.M e.R)
            (e.Substs <GenSubst (t.Const2) (t.Const1)>)
          >;

      e.Other = (e.Conds) (e.Substs);
    };
}
\end{minted}


\subsection{Функция \texttt{PairComp}}

\begin{minted}[breaklines, linenos, fontsize=\small]{Lexer.py:RefalLexer -x}
/*
  <PairComp t.Const t.Const1 t.Const2 t.Eq>
    == t.NewConst (e.Eqs)
*/
PairComp {
  t.Const t.Const1 t.Const2 t.Eq
    = <GetNewConst t.Const>
      (<HandleEmptySubsts t.Const t.Const1 t.Const2 t.Eq>);
}

/*
  <HandleEmptySubst t.Const t.Const1 t.Const2 t.Eq>
    == e.Eqs
*/
HandleEmptySubsts {
  t.Const t.Const1 t.Const2 t.Eq
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , <MapCallTill
        (/* empty */)
        Curry
        (GetEmptySubst t.Const1 t.Const2 (e.Constrs))
        (e.LHS) (e.RHS)
      > : {
      t.Subst
        = <HandleEmptySubsts
            t.Const t.Const1 t.Const2
            (
              (
                AreEqual
                <MapCall Curry (Subst (t.Subst)) (e.LHS) (e.RHS)>
              )
              <CleanUpConstrs t.Subst (e.Constrs)> (e.Conds)
            )
          >
          <HandleEmptySubsts
            t.Const t.Const1 t.Const2
            (
              (AreEqual (e.LHS) (e.RHS))
              (e.Constrs (OR <GenSubstDenial t.Subst>)) (e.Conds)
            )
          >;
      
      /* empty */
        = <HandleNonEmptySubsts t.Const t.Const1 t.Const2 t.Eq>;
    };
}

/*
  <HandleNonEmptySubsts t.Const t.Const1 t.Const2 t.Eq>
    == e.Eqs 
*/
HandleNonEmptySubsts {
  t.Const t.Const1 t.Const2 t.Eq
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , <MapCompose
        (
          <MapCall
            Curry
            (Wrap
              GetNonEmptySubsts t.Const1 t.Const2 (e.Constrs) (e.Conds)
            )
            (e.LHS) (e.RHS)
          >
        )
        (/* empty */) (/* empty */)
      > : (e.ElementarySubsts) (e.CompositeSubsts)
    , <CartesianProductOfOptionSets
        <GenOptionSets (e.ElementarySubsts) (e.CompositeSubsts)>
      > : (e.MultipliedOptions)
    , <MapCall
        Curry
        (NormalizePairOption (e.Conds) (e.Constrs))
        e.MultipliedOptions
      > : {
      /* empty */
        = <ApplyPairOption
            t.Const t.Const1 t.Const2 t.Eq ((/* empty */) (e.Constrs))
          >;

      e.NormalizedOptions
        = <MapCall
            Curry
            (ApplyPairOption t.Const t.Const1 t.Const2 t.Eq)
            e.NormalizedOptions
          >;
    };
}

/*
  <ApplyPairOption t.Const t.Const1 t.Const2 t.Eq t.PairOption>
    == t.NewEq
*/
ApplyPairOption {
  t.Const t.Const1 t.Const2 t.Eq ((e.Substs) (e.Constrs))
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.IrrelevantConstrs) (e.Conds))
    , (t.Const is (t.Const1 (const 1)) (t.Const2 (const 1))) : t.NewCond
    , <MapCall
        Curry
        (Subst (e.Substs <GenSubst (t.Const1 t.Const2) (t.Const)>))
        (e.LHS) (e.RHS)
      > : (e.ReplLHS) (e.ReplRHS)
    = <NormalizeEq
        (
          (AreEqual (e.ReplLHS) (e.ReplRHS))
          (e.Constrs) (e.Conds t.NewCond)
        )
      >;
}
\end{minted}


\subsection{Функция \texttt{BlockComp}}

\begin{minted}[breaklines, linenos, fontsize=\small]{Lexer.py:RefalLexer -x}
/*
  <BlockComp t.BlockConst t.Const s.Index t.Eq>
    == (t.NewConst t.NewIndex t.NewEq)+
*/
BlockComp {
  t.BlockConst t.Const s.Index t.Eq
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds))
    , <MapCompose
        ((GetVars (e.LHS)) (GetVars (e.RHS))) (/* empty */ )
      > : (e.EqVars)
    , <MapCall
        Curry
        (GenBlockOptionSets (e.Constrs) (e.Conds) t.BlockConst)
        e.EqVars
      > : e.OptionSets
    , <CartesianProductOfOptionSets e.OptionSets> : (e.MultipliedOptions)
    , <MapCall
        Curry
        (NormalizeBlockOption (e.Conds) (e.Constrs))
        e.MultipliedOptions
      > : e.NormOptions
    = <MapCall
        Curry
        (ApplyBlockOption t.BlockConst t.Const s.Index t.Eq)
        e.NormOptions
      >;
}

/*
  <ApplyBlockOption t.BlockConst t.Const s.Index t.Eq t.Option>
    == (t.NewConst t.NewIndex t.NewEq)
*/
ApplyBlockOption {
  t.BlockConst t.Const s.Index t.Eq ((e.Substs) (e.Constrs))
    , t.Eq : ((AreEqual (e.LHS) (e.RHS)) (e.IrrelevantConstrs) (e.Conds))
    , <MapCall
        Curry
        (Subst (e.Substs))
        (e.LHS) (e.RHS)
      > : (e.ReplLHS) (e.ReplRHS)
    , <MapCall
        Curry
        (JoinBlocks t.BlockConst)
        (e.ReplLHS) (e.ReplRHS)
      > : (e.JoinedLHS) (e.JoinedRHS)
    , <MapCallCompose
        (NameBlocks t.BlockConst (/* empty */))
        (t.Const s.Index (e.Conds))
        (e.JoinedLHS) (e.JoinedRHS)
      > : (e.NewLHS) (e.NewRHS) t.NewConst s.NewIndex (e.NewConds)
    = (
        t.NewConst s.NewIndex
        <NormalizeEq
          ((AreEqual (e.NewLHS) (e.NewRHS)) (e.Constrs) (e.NewConds))
        >
      );
}

/*
  <JoinBlocks t.BlockConst (e.Elems)> == (e.NewElems)
*/
JoinBlocks {
  t.BlockConst (e.Elems)
    , e.Elems : {
      e.L t.BlockConst (t.BlockConst e.Indices (const s.Num)) e.R
        = <JoinBlocks
            t.BlockConst
            (e.L (t.BlockConst e.Indices (const <Add s.Num 1>)) e.R)
          >;
          
      e.L (t.BlockConst e.Indices (const s.Num)) t.BlockConst e.R
        = <JoinBlocks
            t.BlockConst
            (e.L (t.BlockConst e.Indices (const <Add s.Num 1>)) e.R)
          >;
          
      e.L (t.BlockConst e.Indices1 (const s.Num1))
      (t.BlockConst e.Indices2 (const s.Num2)) e.R
        = <JoinBlocks
            t.BlockConst
            (
              e.L
              (
                t.BlockConst e.Indices1 e.Indices2
                (const <Add s.Num1 s.Num2>)
              )
              e.R
            )
          >;
      
      e.L t.BlockConst t.BlockConst e.R
        = <JoinBlocks t.BlockConst (e.L (t.BlockConst (const 2)) e.R)>;

      e.Other = (e.Elems);
    };
}

/*
  <NameBlocks
    t.BlockConst (e.ProcessedElems) t.Const s.Index (e.Conds) (e.Elems)
  >
    == t.NewConst t.NewIndex (e.NewConds) t.NewElem
*/
NameBlocks {
  t.BlockConst (e.ProcessedElems) t.Const s.Index (e.Conds) (e.Elems)
    , e.Elems : {
      e.L (t.BlockConst e.Indices t.Summand) e.R
        , <NameIndices
            s.Index (e.Indices) (/* empty */)
          > : s.NewIndex (e.NamedIndices)
        , <MapCall Revert (FormPair 1) e.NamedIndices> : e.Exps
        = <NameBlocks
            t.BlockConst (e.ProcessedElems e.L t.Const)
            <GetNewConst t.Const> s.NewIndex
            (e.Conds (t.Const is (t.BlockConst e.Exps t.Summand)))
            (e.R)
          >;
          
      e.Other = t.Const s.Index (e.Conds) (e.ProcessedElems e.Elems);
    };
}

/*
  <NameIndices s.Index (e.NamelessIndices) (e.NamedIndices)>
    == s.NewIndex (e.NamedIndices)
*/
NameIndices {
  s.Index (e.NamelessIndices) (e.NamedIndices)
    , e.NamelessIndices : {
      Index e.RestIndices
        = <NameIndices
            <GetNewIndex s.Index> (e.RestIndices)
            (e.NamedIndices s.Index)
          >;

      /* empty */ = s.Index (e.NamedIndices);
    };
}
\end{minted}

\section{Заключение}

TODO.

\begin{thebibliography}{9}
\bibitem{jez}
Artur Jeż. \emph{Recompression: a simple and powerful technique for word
equations} (\url{https://arxiv.org/abs/1203.3705}).

\bibitem{turchin}
Ф.В. Турчин. \emph{Рефал-5 --- руководство по программированию и справочник}
(\url{http://refal.ru/rf5_frm.htm}).

\bibitem{nemytykh}
А.П. Немытых. \emph{Лекции по языку программирования Рефал}
(\url{http://www.botik.ru/PSI/RCMS/publications/publ-texts-2014/refal-17.pdf}).

\bibitem{konovalov-format}
А.В. Коновалов. \emph{Форматы функций и типы данных в Рефале-5$\lambda$}
(\url{https://bmstu-iu9.github.io/refal-5-lambda/A-formats-and-types.html}).
  
\bibitem{konovalov-style}
А.В. Коновалов. \emph{Рекомендации по стилю оформления кода}
(\url{https://github.com/bmstu-iu9/refal-5-lambda/blob/master/doc/style-guide.m
d}).
  
\end{thebibliography}

\end{document}

