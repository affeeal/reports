\documentclass[12pt]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fancyvrb}

\begin{document}

\section{Теоретическая основа}

Для описания введённых структур данных используется \textit{формальная}
БНФ-грамматика. Все литералы имеют один из трёх префиксов: \texttt{s.},
\texttt{t.} или \texttt{e.}, соотвествующих \textit{символам}, \textit{термам} и
\textit{объектным выражениям} в языке Рефал.

Помимо явных символьных слов типа \texttt{AreEqual}, \texttt{Var} и т.п.
используются следующие терминалы:
\begin{itemize}
  \item \texttt{s.NUMBER} --- любая макроцифра; 
  \item \texttt{s.CHAR} --- любой символ; 
  \item \texttt{s.WORD} --- любое (символьное) слово.
  \item \texttt{e.ANY} --- произвольное объектное выражение.
\end{itemize}

Символы \texttt{*} и \texttt{+} означают повторение литерала ноль и более и
один и более раз соответственно.

\subsection{Представление уравнения}

Рассматриваются уравнения в словах с алфавитом переменных $\Xi$ и алфавитом
констант $\Sigma$. Применение алгоритма Jez'а предполагает хранение
дополнительной информации об уравнении: какие константы являются результатом
сжатия блоков, какие переменные не могут быть пусты и т.д. Поэтому
\textit{уравнение} представляется структурой данных \texttt{t.Eq}:
\begin{Verbatim}
  t.Eq ::= ((AreEqual (t.Elem*) (t.Elem*)) (t.Constr*) (t.Cond*)),
\end{Verbatim}
где выражения \texttt{(t.Elem*)} представляют левую и правую части уравнения,
\texttt{(t.Constr*)} --- ограничения на переменные, а \texttt{(t.Cond*)}
содержит условия на константы.

\textit{Элемент} \texttt{t.Elem} обобщённо представляет \textit{константу} или
\textit{переменную}, соответствующие структурам данных \texttt{t.Const} и
\texttt{t.Var}:
\begin{Verbatim}
  t.Elem ::= t.Var | t.Elem,
  t.Var ::= (Var s.CHAR),
  t.Const ::= (s.CHAR s.NUMBER).
\end{Verbatim}

Назвовём \textbf{сокращением} уравнения удаление всех совпадающих префиксных
и суффиксных элементов его левой и правой частей. В результате получаем
\textbf{сокращённое} уравнение.

Назовём два уравнения \textbf{эквивалентными}, если их сокращение производит
уравнения с одинаковыми левыми и правыми частями.

\subsection{Ограничения на переменные}

\textit{Ограничение на переменную} представляется структурой \texttt{t.Constr}
и описывается в конъюнктивной нормальной форме. Литералами дизъюнкций являются
\textit{рестрикции} (отрицательные условия на переменные) типа \texttt{t.Restr},
подразделяющиеся на \textit{краевые} \texttt{t.BoundRestr} и рестрикции
\textit{на пустоту} \texttt{t.EmptyRestr}:
\begin{Verbatim}
  t.Restr ::= t.BoundRestr | t.EmptyRestr.
\end{Verbatim}

Краевые рестрикции бывают \textit{префиксными} \texttt{t.PrefixRestr} и
\textit{суффиксными} \texttt{t.SuffixRestr}. Они указывают, на какие константы
не может начинаться (кончаться) данная переменная.
\begin{Verbatim}
  t.BoundRestr ::= t.PrefixRestr | t.SuffixRestr,
  t.PrefixRestr ::= (not t.Const starts t.Var),
  t.SuffixRestr ::= (not t.Const ends t.Var).
\end{Verbatim}

Рестрикция на пустоту \texttt{t.EmptyRestr} сообщает, как следует, о
невозможности обращения данной переменной в пустое слово $\varepsilon$:
\begin{Verbatim}
  t.EmptyRestr ::= (not empty t.Var).
\end{Verbatim}

В частности, будем называть переменную \textbf{непустой}, если для неё
существует такая рестрикция, и \textbf{пустой} в противном случае.

Ограничения на переменные \texttt{t.Constr} могут содержать одну или две
рестрикции, в соответствии с чем называются \textit{тривиальными}
\texttt{t.TrivialConstr} и \textit{нетривиальными} \texttt{t.NonTrivialConstr}.
В программе используется только четыре вида ограничений:
\begin{Verbatim}
  t.Constr ::= t.TrivialConstr | t.NonTrivialConstr
  t.TrivialConstr ::= (OR t.Restr),
  t.NonTrivialConstr ::= (OR t.SuffixRestr t.PrefixRestr).
\end{Verbatim}

Говоря далее ограничения мы, как правило, будем подразумевать именно
тривиальные, если не оговорено противное, а также будем экстраполировать
тип рестрикции на ограничение её содержащее: префиксное ограничение,
ограничение на пустоту и т.д.

\subsection{Условия на константы}

\textit{Условие на константу} \texttt{t.Cond} содержит сжимаемые блоки и
соотвествующую этому сжатию константу. Вообще, \textit{блок} \texttt{t.Block}
обозначает степень константы и представляется в виде
\begin{Verbatim}
  t.Block ::= (t.Const t.Exp* (const s.NUMBER)),
\end{Verbatim}
где \texttt{t.Const} --- сжимаемая константа, \texttt{(const s.NUMBER)} ---
обязательный константный показатель, а \texttt{t.Exp ::= (s.WORD s.NUMBER)}
--- переменный показатель степени. Таким образом, условие на константу
представляется в виде
\begin{Verbatim}
  t.Cond ::= (t.Const is t.Block+).
\end{Verbatim}
В программе используется только два типа условий: \textit{парное условие}
\texttt{t.PairCond} и \textit{условие на блок} \texttt{t.BlockCond}:
\begin{Verbatim}
  t.PairCond ::= (t.Const is (t.Const (const 1)) (t.Const (const 1))),
  t.BlockCond ::= (t.Const is t.Block).
\end{Verbatim}

\subsection{Краевые элементы}

Мы хотим применять \texttt{Pair}- и \texttt{Block}-сжатие не только к
тривиальным константам, но и тем, что уже являются результатом сжатия в блоки.
Для корректной обработки ограничений необходимо аккуратно отслеживать, на какие
константы не может начинаться (кончаться) та или иная переменная.

Пусть $\alpha, \gamma \in \Sigma$. Скажем, что $\alpha \in First(\gamma)$, если
существует цепочка условий на константы такая, что
\begin{displaymath}
  \gamma = \beta_1^{i_1} B_1,
  \beta_1 = \beta_2^{i_2} B_2,
  \dots,
  \beta_{n-1} = \alpha^{i_n} B_n,
\end{displaymath}
где $\beta_i \in \Sigma, i = 1, 2, \dots, n - 1$, и $B_j \subset \Sigma, j = 1,
2, \dots, n$. Симметрично определяется множество $Last$-элементов константы.

Иногда удобно использовать обобщение введённых выше понятий: будем
говорить, что константа $\alpha$ является \textbf{краевым} элементом константы
$\gamma$, если $\alpha \in First(\gamma)$ или $\alpha \in Last(\gamma)$.
Обозначение: $\alpha \in Bound(\gamma)$.

\subsection{Слабые и сильные ограничения}

В соответствие с введённым выше понятием краевого элемента, для данной
переменной $X$ и константы $\gamma$ мы можем ввести \textit{иерархические
отношения} на множествах префиксных и суффиксных ограничений $X$ с константами
$First(\gamma)$ и $Last(\gamma)$ соответственно.

Пусть даны два, например, префиксных ограничения с константами $\alpha$ и
$\beta$ (для суффиксных --- аналогично). Если $\alpha \in First(\beta)$, то
$\alpha$-ограничение является \textbf{более сильным}. В то же время
$\beta$-ограничение есть \textbf{более слабое} по сравнению с первым. Имеет
смысл хранить в уравнении лишь самые сильные ограничения.

Например, уравнение содержит ограничения
\begin{Verbatim}
  t.ConstrA1: (OR (not ('A' 1) ends (Var 'X')),
  t.ConstrC0: (OR (not ('C' 0) ends (Var 'X'))
\end{Verbatim}
и условие
\begin{Verbatim}
  t.Cond: (('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1))).
\end{Verbatim}
Тогда в уравнении можно оставить только \texttt{t.ConstrC0}, так как оно
сильнее ограничения \texttt{t.ConstrA1}

\subsection{Избыточные рестрикции и условия}

В результате некоторых действий краевые рестрикции могут стать неактуальными
(с рестрикциями на пустоту такого не происходит), вследствие чего их
можно удалить из уравнения. Будем называть (краевую) рестрикцию
\textbf{избыточной} в двух случаях:
\begin{itemize}
  \item участвующей в ней переменной нет в уравнении;
  \item участвующей в ней константы нет в уравнении, а также в правых частях
  условий на константы.
\end{itemize}

Условие (на константу) также может стать \textbf{избыточным}. Это происходит в
следующих случаях:
\begin{itemize}
  \item константа в левой части условия не участвует в уравнении и не является
  $Bound$-элементом какой-либо другой константы;
  \item условие имеет парный тип, обеих констант его правой части нет
  в уравнении и они не являются левыми частями каких-либо других условий.
\end{itemize}

\subsection{Обработка нетривиальных ограничений}

Нетривиальные ограничения на переменные также могут подвергаться обработке.
Пусть уравнение содержит
\begin{Verbatim}
  t.NonTrivialConstr: (OR t.SuffixRestr t.PrefixRestr).
\end{Verbatim}
Если в уравнении найдётся более сильное в сравнении с
\texttt{(OR t.SuffixRestr)} или \texttt{(OR t.PrefixRestr)} краевое ограничение,
то \texttt{t.NonTrivialConstr} \textbf{выполняется тривиально}, и его можно
удалить. Это же происходит и в случаях, когда хотя бы одна из рестрикций
\texttt{t.SuffixRestr} и \texttt{t.PrefixRestr} избыточна.

Иногда нам потребуется модифицировать нетривиальные ограничения. Например, мы
хотим выполнить подстановку, конфликтующую с одной из рестрикций такого
ограничения. В таком случае мы \textbf{вынуждаем} выполнение другой рестрикции,
превращая тем самым нетривиальное ограничение в тривиальное.

\subsection{Нормальное уравнение}

Будем называть уравнение \textbf{нормальным}, если оно несократимо, не содержит
слабых и тривиально выполняющихся ограничений и избыточных рестрикций и условий.
Также потребуем, чтобы в нормальном уравнении все ограничения были
отсортированы, равно как и показатели степеней \texttt{t.Exp} условий на блок.

Нормальные уравнения представляют особый интерес для нас. Именно такие уравнения
возращают и ожидают получить на вход функции \texttt{Pick}, \texttt{SubstIndex},
\texttt{PairComp} и \texttt{BlockComp}.

\section{Функция \texttt{Pick}}

Скажем, что решение уравнения \textbf{неминимальное}, если его левая и правая
части состоят из непустых переменных и только них.

Функция \texttt{Pick} принимает макроцифру \texttt{s.NUMBER} и уравнения
\texttt{t.Eq+}. Выбрав уравнение под номером \texttt{s.NUMBER}, подставляет
все его пустые переменные в $\varepsilon$. Функция возращает
\begin{itemize}
  \item \texttt{Success}, если новое уравнение эквивалентно уравнению
  $\varepsilon = \varepsilon$;
\item \texttt{NotMinimal}, если решение такого уравнения неминимальное;
\item новое нормальное уравнение в остальных случаях.
\end{itemize}

Здесь и далее часто требуется выполнять \textit{нерекурсивные подстановки} в
выражение. Определим для этого специальный формат \texttt{t.Subst}:
\begin{Verbatim}
  t.Subst ::= (assign (e.ANY) (e.ANY)),
\end{Verbatim}
где первое выражение \texttt{e.ANY} --- заменяемое, а второе --- новое.

\texttt{Pick} имеет довольно простую реализацию: из множества всех переменных
уравнения вычитаются непустые. Для оставшихся переменных генерируются
и выполняются подстановки в $\varepsilon$. Если получившееся уравнение
эквивалентно $\varepsilon = \varepsilon$, возвращаем, как говорилось,
\texttt{Success}. Иначе получаем множество констант нового уравнения и
возвращаем \texttt{NotMinimal}, если оно пусто, и получившееся уравнение с
удалёнными (в связи с пустотой) избыточными рестрикциями в противном случае.

\end{document}

