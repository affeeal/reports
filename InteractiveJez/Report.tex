\documentclass[12pt]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fancyvrb}
\usepackage{amsfonts}
\usepackage{mathtools}

\begin{document}

\section{Теоретическая основа}

Для описания структур данных используется формальная БНФ-грамматика.
Все литералы имеют один из трёх префиксов: \texttt{s.}, \texttt{t.} или
\texttt{e.}, соотвествующие \textit{символам}, \textit{термам} и
\textit{объектным выражениям} языка Рефал.

Помимо явных символьных слов (\texttt{AreEqual}, \texttt{Var} и т.п.)
используются следующие терминалы:
\begin{itemize}
  \item \texttt{s.NUMBER} --- любая макроцифра; 
  \item \texttt{s.CHAR} --- любой символ; 
  \item \texttt{s.WORD} --- любое символьное слово.
  \item \texttt{e.ANY} --- произвольное объектное выражение.
\end{itemize}

Символы \texttt{*} и \texttt{+} означают повторение литерала ноль и более и
один и более раз соответственно.

Помимо \texttt{::=} используется инфиксный оператор \texttt{:}, означающий,
что только в данном контексте выражение слева представляется как выражение
справа.


\subsection{Представление уравнения}

Рассматриваются уравнения в словах с алфавитом переменных $\Xi$ и алфавитом
констант $\Sigma$. Применение алгоритма Jez'а предполагает хранение
дополнительной информации об уравнении: какие константы являются результатом
сжатия блоков, какие переменные не могут быть пусты и т.д. Поэтому
\textit{уравнение} представляется структурой данных \texttt{t.Eq}:
\begin{Verbatim}
  t.Eq ::= ((AreEqual (e.LHS) (e.RHS)) (e.Constrs) (e.Conds)),
\end{Verbatim}
где \texttt{e.LHS: t.Elem*} и \texttt{e.RHS: t.Elem*} представляют левую и
правую части уравнения, \texttt{e.Constrs: t.Constr*} --- ограничения на
переменные, а \texttt{e.Conds: t.Cond*} содержит условия на константы.

\textit{Элемент} \texttt{t.Elem} обобщённо представляет \textit{константу} или
\textit{переменную}, соответствующие структурам данных \texttt{t.Const} и
\texttt{t.Var}:
\begin{Verbatim}
  t.Elem ::= t.Var | t.Elem,
  t.Var ::= (Var s.CHAR),
  t.Const ::= (s.CHAR s.NUMBER).
\end{Verbatim}

Назвовём \textbf{сокращением} уравнения удаление всех совпадающих префиксных
и суффиксных элементов его левой и правой частей. В результате получим
\textit{сокращённое} уравнение.

Два уравнения будем называть \textbf{эквивалентными}, если их сокращение
производит уравнения с одинаковыми левыми и правыми частями.


\subsection{Ограничения на переменные}

\textit{Ограничения на переменные} представляются структурой \texttt{t.Constr}
и описываются в конъюнктивной нормальной форме. Литералами дизъюнкций являются
\textit{рестрикции} (отрицательные условия на переменные) типа \texttt{t.Restr},
подразделяющиеся на краевые \texttt{t.BoundRestr} и рестрикции на пустоту
\texttt{t.EmptyRestr}:
\begin{Verbatim}
  t.Restr ::= t.BoundRestr | t.EmptyRestr.
\end{Verbatim}

\textit{Краевые} рестрикции бывают \textit{префиксными} \texttt{t.PrefixRestr} и
\textit{суффиксными} \texttt{t.SuffixRestr}. Они указывают, на какие константы
не может начинаться или кончаться данная переменная.
\begin{Verbatim}
  t.BoundRestr ::= t.PrefixRestr | t.SuffixRestr,
  t.PrefixRestr ::= (not t.Const starts t.Var),
  t.SuffixRestr ::= (not t.Const ends t.Var).
\end{Verbatim}

\textit{Рестрикция на пустоту} \texttt{t.EmptyRestr} сообщает, как следует, о
невозможности обращения данной переменной в пустое слово $\varepsilon$:
\begin{Verbatim}
  t.EmptyRestr ::= (not empty t.Var).
\end{Verbatim}

В частности, будем называть переменную \textbf{непустой}, если для неё
существует такая рестрикция.

Ограничения на переменные \texttt{t.Constr} могут содержать одну или две
рестрикции, в соответствии с чем называются \textit{тривиальными}
\texttt{t.TrivialConstr} и \textit{нетривиальными} \texttt{t.NonTrivialConstr}.
В программе используется только четыре вида ограничений:
\begin{Verbatim}
  t.Constr ::= t.TrivialConstr | t.NonTrivialConstr
  t.TrivialConstr ::= (OR t.Restr),
  t.NonTrivialConstr ::= (OR t.SuffixRestr t.PrefixRestr).
\end{Verbatim}

Говоря далее \textit{ограничения} мы, как правило, будем подразумевать именно
тривиальные, если не оговорено противное, а также будем экстраполировать
тип рестрикции на ограничение её содержащее: префиксное ограничение,
ограничение на пустоту и т.д.


\subsection{Условия на константы}

\textit{Условие на константу} \texttt{t.Cond} содержит сжимаемые блоки и
соотвествующую этому сжатию константу. Вообще, \textit{блок} \texttt{t.Block}
обозначает степень константы и представляется в виде
\begin{Verbatim}
  t.Block ::= (t.Const t.Exp* (const s.NUMBER)),
\end{Verbatim}
где \texttt{t.Const} --- сжимаемая константа, \texttt{(const s.NUMBER)} ---
обязательный константный показатель, а \texttt{t.Exp ::= (s.WORD s.NUMBER)}
--- переменный показатель степени. Таким образом, условие на константу
представляется в виде
\begin{Verbatim}
  t.Cond ::= (t.Const is t.Block+).
\end{Verbatim}
В программе используется только два типа условий: \textit{парное условие}
\texttt{t.PairCond} и \textit{условие на блок} \texttt{t.BlockCond}:
\begin{Verbatim}
  t.PairCond ::= (t.Const is (t.Const (const 1)) (t.Const (const 1))),
  t.BlockCond ::= (t.Const is t.Block).
\end{Verbatim}


\subsection{Краевые элементы} \label{bound-elements}

Мы хотим применять \texttt{Pair}- и \texttt{Block}-сжатие не только к
тривиальным константам, но и тем, что уже являются результатом сжатия в блоки.
Для корректной обработки ограничений необходимо аккуратно отслеживать, на какие
константы не может начинаться и кончаться та или иная переменная.

Пусть $\alpha, \gamma \in \Sigma$. Скажем, что $\alpha \in First(\gamma)$, если
существует цепочка условий на константы такая, что
\begin{displaymath}
  \gamma = \beta_1^{i_1} B_1,\quad
  \beta_1 = \beta_2^{i_2} B_2,\quad
  \dots,\quad
  \beta_{n-1} = \alpha^{i_n} B_n,
\end{displaymath}
где $\beta_i \in \Sigma, \ i = 1, 2, \dots, n - 1$, и $B_j \in \Sigma^*,
\ j = 1, 2, \dots, n$. Симметрично определяется множество $Last$-элементов
константы. Вообще, делая далее какое-либо утверждение о $First$-элементах
константы будем считать, что оно симетрично выполняется и для её
$Last$-множества.

Иногда удобно использовать обобщение введённых выше понятий: будем
говорить, что константа $\alpha$ является \textbf{краевым} элементом константы
$\gamma$, если $\alpha \in First(\gamma)$ или $\alpha \in Last(\gamma)$.
Обозначение: $\alpha \in Bound(\gamma)$.


\subsection{Слабые и сильные ограничения}

В соответствии с введённым в разделе \ref{bound-elements} понятием краевого
элемента, для данной переменной $X$ и константы $\gamma$ мы можем ввести
\textit{иерархические отношения} на множествах префиксных и суффиксных
ограничений $X$ с константами $First(\gamma)$ и $Last(\gamma)$ соответственно.

Пусть даны два, например, префиксных ограничения с константами $\alpha$ и
$\beta$ (для суффиксных --- аналогично). Если $\alpha \in First(\beta)$, то
$\alpha$-ограничение является \textbf{более сильным}. В то же время
$\beta$-ограничение есть \textbf{более слабое} по сравнению с первым. Имеет
смысл хранить в уравнении лишь самые сильные ограничения.

% Возможно, следующий абзац избыточный.
Пусть, например, уравнение содержит ограничения
\begin{Verbatim}
  t.Constr1: (OR (not ('A' 1) ends (Var 'X')),
  t.Constr2: (OR (not ('C' 0) ends (Var 'X'))
\end{Verbatim}
и условие
\begin{Verbatim}
  t.Cond: (('A' 1) is (('B' 0) (const 1)) (('C' 0) (const 1))).
\end{Verbatim}
Тогда в уравнении можно оставить только \texttt{t.Constr2}, так как оно
сильнее ограничения \texttt{t.Constr1}


\subsection{Избыточные рестрикции и условия}

В результате некоторых действий краевые рестрикции могут стать неактуальными
(с рестрикциями на пустоту такого не происходит), вследствие чего их
можно удалить из уравнения. Будем называть краевую рестрикцию
\textbf{избыточной} в двух случаях:
\begin{itemize}
  \item участвующей в ней переменной нет в уравнении;
  \item участвующей в ней константы нет в уравнении, а также в правых частях
  условий на константы.
\end{itemize}

Условие на константу также может стать \textbf{избыточным}. Это происходит в
следующих случаях:
\begin{itemize}
  \item константа в левой части условия не участвует в уравнении и не является
  $Bound$-элементом какой-либо другой константы;
  \item условие имеет парный тип, обеих констант его правой части нет в
  уравнении и на них нет каких-либо других условий.
\end{itemize}


\subsection{Обработка нетривиальных ограничений}

Нетривиальные ограничения на переменные также могут подвергаться обработке.
Пусть уравнение содержит
\begin{Verbatim}
  t.NonTrivialConstr: (OR t.SuffixRestr t.PrefixRestr).
\end{Verbatim}
Если в уравнении найдётся равное или более сильное в сравнении с
\texttt{(OR t.SuffixRestr)} или \texttt{(OR t.PrefixRestr)} краевое
ограничение, то \texttt{t.NonTrivialConstr} \textbf{выполняется тривиально},
и его можно удалить. Это же происходит и в случае, когда избыточна хотя
бы одна из рестрикций \texttt{t.SuffixRestr} и \texttt{t.PrefixRestr}.

Будем называть префиксную рестрикцию с константой $\alpha \in \Sigma$
\textbf{зависимой} относительно некоторого $\beta \in \Sigma$, если
$\alpha \in First(\beta) \cup \{\beta\}$. В противном случае рестрикция
называется \textbf{независимой}.

Иногда нам потребуется модифицировать нетривиальные ограничения. Например, мы
хотим выполнить \textit{подстановку}
\begin{displaymath}
  X \to X \alpha, \quad X \in \Xi, \quad \alpha \in \Sigma
\end{displaymath}
при наличии такого ограничения с зависимой относительно $\alpha$ рестрикцией.
Мы \textbf{вынуждаем} выполнение второй рестрикции, превращая тем самым
нетривиальное ограничение в тривиальное.


\subsection{Подстановки}

В алгоритме повсеместно требуется выполнять нерекурсивные подстановки
выражений. Определим для этого специальный формат \texttt{t.Subst}:
\begin{Verbatim}
  t.Subst ::= (assign (e.Old) (e.New)),
\end{Verbatim}
где выражение \texttt{e.Old: e.ANY} --- заменяемое, а \texttt{e.New: e.ANY}
--- новое.

Практически всегда подстановка заключается в извлечении у переменной сзади или
спереди константы и обращении этой переменной в пустое слово. Например,
\begin{displaymath}
  X \to X \alpha, \ Y \to \beta Y, \ Z \to \varepsilon, \quad X, Y, Z \in \Xi,
  \quad \alpha, \beta \in \Sigma.
\end{displaymath}
Такие подстановки называются соответственно \textbf{суффиксными},
\textbf{префиксными} и \textbf{пустыми}.

В контексте конкретной задачи подстановки могут быть \textbf{элементарными} и
\textbf{композитными}. Это означает, что для достижения некоторой цели могут
потребоваться одна или несколько одновременно выполняющихся подстановок.


\subsection{Нормальное уравнение}

Будем называть уравнение \textbf{нормальным}, если оно несократимо, не содержит
слабых и тривиально выполняющихся ограничений и избыточных рестрикций и условий.
Также потребуем, чтобы в нормальном уравнении все ограничения были
отсортированы, равно как и показатели степеней \texttt{t.Exp} условий на блок.
В практической реализации используется быстрая сортировка, принимающая
функцию-компаратор. Определив такие компараторы для ограничений и показателей
степеней появляется возможность эффективно сортировать указанные элементы.

Нормальные уравнения представляют особый интерес для нас. Именно такие уравнения
возращают и ожидают получить на вход функции \texttt{Pick}, \texttt{SubstIndex},
\texttt{PairComp} и \texttt{BlockComp}.



\section{Функция \texttt{Pick}}

Скажем, что решение уравнения \textbf{неминимальное}, если его левая и правая
части состоят из непустых переменных и только них.

Функция \texttt{Pick} принимает номер уравнения \texttt{s.Number: s.NUMBER}
и сами уравнения \texttt{e.Eqs: t.Eq+}. Все переменные уравнения под номером
\texttt{s.Number}, для которых возможна подстановка в пустое слово, обращает в
$\varepsilon$ и возвращает
\begin{itemize}
  \item \texttt{Success}, если новое уравнение эквивалентно уравнению
  $\varepsilon = \varepsilon$;
  
  \item \texttt{NotMinimal}, если решение такого уравнения неминимальное;
    
  \item новое нормальное уравнение в остальных случаях.
\end{itemize}

\texttt{Pick} имеет довольно простую реализацию: из множества всех переменных
уравнения вычитаются непустые. Для оставшихся переменных генерируются
и выполняются подстановки в пустое слово. Если получившееся уравнение
эквивалентно $\varepsilon = \varepsilon$, возвращаем \texttt{Success}.
В противном случае получаем множество констант нового уравнения. Если это
множество пусто, возвращаем \texttt{NotMinimal}, иначе --- получившееся
нормализованное уравнение.



\section{Функция \texttt{SubstIndex}}

Функция \texttt{SubstIndex} принимает индекс \texttt{s.Index: s.WORD},
показатели \texttt{e.Exps: t.Exp+}, уравнение \texttt{t.Eq} и выполянет
подстановку показателей на место данного индекса.

Для всякого условия на блок с показателем \texttt{(s.Index s.NUMBER)}
производится замена этого показателя на множество \texttt{e.Exps},
каждый элемент которого домножен на постоянную \texttt{s.NUMBER}.
Обычно после этого шага порядок показателей нарушается --- их
нужно отсортировать.

В результате подстановки могло получиться условие вида
\begin{Verbatim}
  t.Cond: (t.Const is (t.BlockConst (const 0))).
\end{Verbatim}
Такое условие \textit{коллапсирует}, так как коллапсирует содержавшийся в нём
блок. Нам полезно на месте генерировать подстановки констант из левых частей
таких условий в $\varepsilon$: позже мы осуществим эти подстановки в левой и
правой частях уравнения, чтобы избавиться от ненужных констант.

Также мы могли получить условия с разными левыми, но одинаковыми правыми
частями:
\begin{Verbatim}
  t.Cond1: (t.Const1 is (t.BlockConst e.Exps (const s.NUMBER))),
  t.Cond2: (t.Const2 is (t.BlockConst e.Exps (const s.NUMBER))).
\end{Verbatim}
В таком случае мы сохраняем лишь одно условие (в реализации --- с
лексикографически наименьшей константой), например, \texttt{t.Cond1}, и
генерируем замену константы второго условия \texttt{t.Const2} на
\texttt{t.Const1}.

Теперь выполняем в уравнении все сгенерированные подстановки (констант
коллапсировавших и заменённых условий). Остаётся лишь нормализовать полученное
уравнение.



\section{Функция \texttt{PairComp}}


\subsection{Вхождения сжимаемой пары} \label{pair-occurency}

Рассмотрим возможности появления пары $\alpha \beta \in \Sigma^+ $ в
уравнении. Пусть одна из его частей представляется как 
\begin{equation}
  \Phi \alpha \beta \Psi, \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*.
\end{equation}
Здесь получаем \textbf{явное} вхождение исходной пары. Если часть уравнения
имеет вид
\begin{equation} \label{pair-occurency:2}
  \Phi X \beta \Psi, \quad X \in \Xi, \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*,
\end{equation}
мы можем рассмотреть случай, когда решение $X$ оканчивается на $\alpha$, т.е.
$X = X\alpha$. Выполнив подстановку $X \to X\alpha$ (если это возможно)
получим новое явное вхождение пары $\alpha \beta$. Поэтому нам интересна
ситуация \ref{pair-occurency:2}. Будем называть такое вхождение пары
\textbf{перекрёстным}.

Случай
\begin{equation} \label{pair-occurency:3}
  \Phi \alpha Y \Psi, \quad Y \in \Xi, \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*
\end{equation}
симметричен предыдущему: имеем перекрёстное вхождение пары $\alpha \beta$ и
можем получить явное, выполнив подстановку $Y \to \beta Y$.

Наконец, часть уравнения может представляться в виде
\begin{equation} \label{pair-occurency:4}
  \Phi X Y \Psi, \quad X, Y \in \Xi, \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*.
\end{equation}
В таком случае новое явное вхождение появляется (при отсутствии соответствующих
ограничений) с выполненными одновременно подстановками $X \to X \alpha$ и
$Y \to \beta Y$.

Пара $\alpha \beta$ также может входить в уравнение \textbf{неявно}, не являясь
началом или концом решения, а находясь полностью внтури него. Такая
ситуация в силу неминимальности нам неинтересна.


\subsection{Существенные подстановки} \label{essential-substs}

Обратим внимание на случаи \ref{pair-occurency:2}-\ref{pair-occurency:4}
раздела \ref{pair-occurency}. Здесь краевые подстановки в своём контексте
порождают новые явные вхождения в уравнение пары $\alpha \beta$, поэтому они
называются \textbf{существенными}. Существенные элементарные и композитные
подстановки включают одну и две подстановки соответственно. Например,
подстановки в \ref{pair-occurency:2} и \ref{pair-occurency:3} являются
существенными элементарными, а в \ref{pair-occurency:4} --- существенной
композитной.

В реализации нам потребуется понятие \textbf{специальной} подстановки: таковыми
будем называть существенные элементарные подстановки, являющиеся частью
какой-либо существенной композитной подстановки.

Описанные выше подстановки являются \textbf{непустыми}, но и \textbf{пустые}
подстановки могут порождать новые явные пары, также называясь в этом случае
\textbf{существенными}. Пусть часть уравнения представляется в виде
\begin{equation}
  \Phi \alpha \Omega \beta \Psi, \quad \Omega \in \Xi^+, \quad \Phi, \Psi \in
  (\Sigma \cup \Xi)^*,
\end{equation}
где хотя бы одна переменная в $\Omega$ может быть пуста. Пусть такой переменной
будет $W \in \Xi$. Если максимальный блок $W^i$, $i \in \mathbb{N}$, следует
непосредственно за $\alpha$, обратив переменную в $\varepsilon$ мы получим или
новую явную пару $\alpha \beta$, или новую перекрёстную пару при соседстве
$\alpha$ с новой переменной, следующей прямо за $W^i$. Получаем симметричную
ситуацию, если $W^i$ непосредственно предшествует $\beta$. Если же $W^i$
находится внутри $\Omega$, подстановка в пустое слово даст новое соседство двух
переменных, следовательно --- новое перекрёстное вхождение, где явная пара
может быть порождена существенной композитной подстановкой.

Мы видим, что во всех случаях имеет смысл совершать подстановку $W \to
\varepsilon$. Аналогично разбираются случаи
\begin{equation}
  \Phi X \Omega \beta \Psi, \quad X \in \Xi, \quad \Omega \in (\Xi / X)^+,
  \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*,
\end{equation}
\begin{equation}
  \Phi \alpha \Omega Y \Psi, \quad Y \in \Xi, \quad \Omega \in (\Xi / Y)^+,
  \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*,
\end{equation}
\begin{equation}
  \Phi X \Omega Y \Psi, \quad X, Y \in \Xi, \quad \Omega \in (\Xi / X / Y)^+,
  \quad \Phi, \Psi \in (\Sigma \cup \Xi)^*,
\end{equation}

Важно, чтобы среди $\Omega$ была хотя бы одна переменная, для которой возможна
пустая подстановка.


\subsection{Опции \texttt{PairComp}} \label{pair-option}

Для данного уравнения может обнаружиться множество пустых и непустых
существенных подстановок. Вообще, не любая их комбинация ведёт к решению.
Необходимо перебрать их всевозможные сочетания и уже среди них искать
успешные.

\textbf{Опция} уравнения --- легковесная абстракция для представления такого
набора. В \texttt{PairComp} опция представляется типом \texttt{t.PairOption:}
\begin{Verbatim}
  t.PairOption ::= ((e.Substs) (e.Constrs)).
\end{Verbatim}
Здесь \texttt{e.Substs} хранит определённую комбинацию подстановок, а
\texttt{e.Constrs} --- накладываемые ограничения при этих подстановках.
В совокупности ограничения могут быть противоречивы --- такие опции
отбрасываются сразу, не применяясь к уравнению. Остальные же
\textit{нормализуются} и производят новые уравнения.

Опции тоже имеет смысл приводить к \textbf{нормальному виду}. Для
\texttt{t.PairOption} это означает отсутствие дубликатов, тривиально
выполняющихся ограничений и конфликтующих рестрикций. Ограничения нормальной
опции \textit{модифицируются}: при префиксных подстановках удаляются
независимые (зависимых на этом этапе быть не может --- противоречие)
префиксные и пустые ограничения, при суффиксных --- симметрично. Наконец,
к ограничениям опции прибавляются ограничения уравнения, чтобы в дальнейшем
их уже не пришлось как-либо изменять.


\subsection{Реализация \texttt{PairComp}}

Функция принимает константу для замены \texttt{t.ReplConst}, элементы сжимаемой
пары \texttt{t.Const1} и \texttt{t.Const2}, а также уравнение \texttt{t.Eq}.
\texttt{PairComp} генерирует новую константу для замены и новые уравнения,
выполняя различные комбинаций существенных пустых и непустых подстановок
исходного уравнения \texttt{t.Eq}.

В начале рекурсивно генерируются ветви с выполняющимися и невыполняющимися
существенными пустыми подстановками. Подстановки отбираются по одной, как
описано в разделе \ref{essential-substs}. Для первой ветви сразу удаляются
избыточные ограничения, возникшие с подстановкой переменной в $\varepsilon$,
а к ограничениям второй ветви прибавляется непустота переменной.

Остановимся на какой-нибудь ветви. Как только на ней заканчиваются возможные
существенные пустые подстановки, начинается поиск всех существенных непустых
--- элементарных и композитных. Они отбираются с учётом существующих краевых
ограничений, поэтому на выходе получаем только возможные подстановки. Среди
них удаляются дубликаты, а также определяются специальные подстановки.

Теперь можно генерировать первичные наборы опций, которые в дальнейшем будут
декартово переменожаться. Говоря \textit{подстановка выполняется} будем
подразумевать осуществление данной подстановки без накладываемых ограничений.
Говоря, что \textit{подстановка не выполняется}, будем иметь в виду невыполнение
подстановки с добавлением соответствующего ограничения.

Для всякой элементарной неспециальной подстановки генерируется
\textbf{элементарный набор} из двух опций: в одной из них подстановка
выполняется, а в другой --- нет.

Для каждой композитной подстановки в зависимости от числа составляющих её
специальных подстановок производится один из трёх \textbf{композитных наборов}.
\begin{enumerate}
  \item \textit{Обе} подстановки специальные. Набор содержит четыре опции:
  в первой выполняются обе подстановки, во второй выполняется одна и не
  выполняется другая, в третьей --- наоборот, а в четвёртой не выполняется
  ни одна из подстановок.
  
\item \textit{Одна} подстановка специальная, другая --- нет. В наборе
  три опции: в первой выполняются обе подстановки, во второй выполняется
  специальная и не выполняется оставшаяся, в третьей просто не выполняется
  специальная.
    
\item \textit{Ни одна} из подстановок не является специальной. Набор
  состаляют две опции. В первой выполняются обе подстановки, а во второй не
  выполняется или одна, или другая. \textit{Этот набор единственный во
  всей программе порождает нетривиальные ограничения}.
\end{enumerate}

Производится декартово произведение полученных наборов. Пока есть два и более
таких множества, берётся пара наборов, и их опции переменожаются. Результат
--- уже одно, а не два множества --- возвращается в исходное семейство, и
процедура повторяется.

\textit{Мы получили опции уравнения такими, какими мы определяли их в разделе
\emph{\ref{pair-option}}}. Нужно попытаться нормализовать эти опции: некоторые
из них, возможно, будут удалены как противоречивые. Оставшиеся же
дорабатываются как описывается в упомянутом разделе.

Наконец, опции применяются к уравнению. Если к этому моменту нет ни одной опции
(изначально не было существенных непустых подстановок или все опции оказались
противоречивы), искусственно применяется \textit{пустая опция} вида
\texttt{((/* no substs */) (/* no constrs */))}. Для каждой опции все её
подстановки применяются к уравнению. Образовавшиеся явные пары сжимаются.
Ограничения полученного уравнения подменяются ограничениями опции, и результат
нормализуется.



\section{Функция \texttt{BlockComp}}


\subsection{Сжатие переменной в блок} \label{block-comp}

Предположим, что в уравнении нет тривиальных ограничений на его переменную $X
\in \Xi$ (\textit{нетривиальные ограничения не обрабатываются}). При сжатии $X$
в блок $\alpha \in \Sigma$ необходимо рассмотреть два случая:
\begin{itemize}
  \item переменная \textit{коллапсирует} в блок:
  \begin{equation} \label{block:collapsed}
    X \to \alpha^i, \ i \in \mathbb{N} \cup \{ 0 \}.
  \end{equation}

  \item происходит извлечение максимальных префиксных и суффиксных блоков у
  переменной:
  \begin{equation} \label{block:extracted}
    X \to \alpha^i X \alpha^j, \ i, j \in \mathbb{N} \cup \{ 0 \}.
  \end{equation}
  Теперь $X$ не может начинаться или кончаться на $\alpha$ в силу
  максимальности извлечённых блоков, а также не может быть пустым (иначе
  переменная сжималась бы в блок)
  \begin{equation} \label{block:constraints}
    X \ne \alpha X, \quad X \ne X \alpha, \quad X \ne \varepsilon.
  \end{equation}
\end{itemize}

Допустим, в уравнении есть префиксные ограничения на $X$, независимые
относительно $\alpha$ (суффиксные ограничения здесь и далее обрабатываются
симметричным образом). Случай \eqref{block:extracted} теперь ветвится:
\begin{itemize}
  \item Префиксный блок пуст, извлекается только суффиксный:
  \begin{displaymath}
    X \to X \alpha^j, \ j \in \mathbb{N} \cup \{ 0 \}.
  \end{displaymath}
  Исходные ограничения сохраняются с присоединением ограничений
  \eqref{block:constraints}.
  
  \item Префиксный блок \textit{не} пуст:
  \begin{displaymath}
    X \to \alpha^i X \alpha^j, \ i, j \in \mathbb{N} \cup \{ 0 \}.
  \end{displaymath}

  Исходные ограничения удаляются, а \eqref{block:constraints} ---
  добавляются.
\end{itemize}

Пусть вместе с присутствующими или отсутствующими независимыми префиксными
ограничениями на $X$ переменная также непуста. Это влияет только на сжатие
в блок \eqref{block:collapsed}: подстановка заменяется на
\begin{equation} \label{block:non-empty-collapsed}
  X \to \alpha^{i + 1}, \ i \in \mathbb{N} \cup \{ 0 \},
\end{equation}
а ограничения на переменную, если были в уравнении, удаляются.

Теперь рассмотрим случай, когда уравнение содержит только префиксные
ограничения --- зависимые и, возможно, независимые. Сжатие в блок
\eqref{block:collapsed} становится \textit{невозможным}; оно заменяется на
пустую подстановку $X \to \varepsilon$ с удалением всех ограничений. Извлечение
префиксного блока в \eqref{block:extracted} также незаконно, поэтому
извлекается только суффиксный:
\begin{equation} \label{block:dependent-prefix}
  X \to X \alpha^j, \ j \in \mathbb{N} \cup \{ 0 \};
\end{equation}
прежние ограничения сохраняются, а из новых \eqref{block:constraints}
добавляются только $X \ne \varepsilon$ и $X \ne X \alpha$, так как $X \ne
\alpha X$ равно или слабее по силе существующих зависимых префиксных
ограничений.

Наконец, если $X$ ещё и не пуст, коллапсирование в $\varepsilon$ вообще
блокируется, и остаётся только извлечение \eqref{block:dependent-prefix}.

В Рефале сжатая в блок константа, например, \texttt{('A' 0)} при таких
подстановках имеет вид
\begin{Verbatim}
  (('A' 0) Index (const 0)).
\end{Verbatim}
Здесь \texttt{Index} есть переменная пока что \textit{безымянного} показателя степени. В будущем,
как станут известны все такие безымянные блоки уравнения, на место
\texttt{Index} встанет конкретный переменный показатель: например,
\texttt{(i1 1)}.


\subsection{Опции \texttt{BlockComp}} \label{block-option}

Опция \texttt{t.BlockOption}, как и \texttt{t.PairOption}, хранит комбинации
подстановок и модифицируемые ограничения, с применением которых исходное
уравнение порождает новые. Ограничения \texttt{block}-опции сразу будем
делить на \textit{добавляемые} к уравнению и \textit{исключаемые} из него. Так
делать, вообще, необязательно, но нынешняя реализация строится на этом подходе.
Таким образом, \texttt{t.BlockOption} представляется в виде
\begin{Verbatim}
  ((e.Substs) (e.AddedConstrs) (e.ExcludedConstrs)). 
\end{Verbatim}

В отличие от набора \texttt{t.PairOption}, декартово произведение
\texttt{block}-опций всегда совместимо, поскольку мы никак не обрабатываем
нетривиальные ограничения (а если бы даже обрабатывали, недопустима ситуация
с двумя зависимыми относительно сжимаемой константы рестрикциями, содержащимися
в одном ограничении --- т.е. мы всегда сможем выбрать \textit{удовлетворяющую}
нас рестрикцию). Тем не менее, в таких наборах всё так же нужно удалять
тривиально выполняющиеся и избыточные в связи с коллапсированием переменной в
блок или $\varepsilon$ ограничения.

Наконец, к изменённым ограничениям опции прибавляются ограничения уравнения
(для заменещения в дальнейшем).


\subsection{Реализация \texttt{BlockComp}}

Функция принимает константу для сжатия \texttt{t.BlockConst}, константу
и индекс \texttt{t.NewConst} и \texttt{s.NewIndex} соответственно для введения
условий и уравнение \texttt{t.Eq}.

Для каждой переменной уравнения генерируется первичный набор опций по правилам,
описанным в разделах \ref{block-comp} и \ref{block-option}. Число опций в
наборе варьируется от одной пустой (если зависимые и префиксные, и суффиксные
ограничения, а переменная непуста) до целых пяти в случае, когда
префиксные и суффиксные ограничения независимы (здесь одна опция ---
коллапсирование переменной, другие четыре есть результат декартова произведения
$2 \times 2$ опций с извлечением префиксных и суффиксных блоков).

Производится декартово произведение таких первичных наборов. Полученные опции
нормализуются и применяются к уравнению.

После применения подстановок опции части уравнения содержат безымянные блоки,
описанные в конце раздела \ref{block-comp}. Такие стоящие рядом друг с другом
или сжимаемой константой блоки \textit{объединяются}, образуя новую степень
\texttt{t.BlockConst}. В частности, две стоящие рядом исходные константы
преобразуются в единый блок-квадрат.

После объединения всех указанных блоков безымянные индексы \texttt{Index}
в лексикографическом порядке заменяются на конкретные переменные показатели
степени. Полученные блоки обозначаются и переносятся в условия на константы.

Наконец, функция возвращает неиспользованные константу и индекс, а также
нормализованное получившееся уравнение.

\end{document}

