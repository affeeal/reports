\documentclass[12pt]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fancyvrb}

\begin{document}

\section{Теоретическая основа}

Для описания введённых структур данных используется \textit{формальная}
БНФ-грамматика. Все литералы имеют один из трёх префиксов: \texttt{s.},
\texttt{t.} или \texttt{e.}, соотвествующих \textit{символам}, \textit{термам} и
\textit{объектным выражениям} в языке Рефал.

Помимо явных символьных слов типа \texttt{AreEqual}, \texttt{Var} и т.п.
используются следующие нетерминалы:
\begin{itemize}
  \item \texttt{s.NUMBER} --- любая макроцифра; 
  \item \texttt{s.CHAR} --- любой символ; 
  \item \texttt{s.WORD} --- любое (символьное) слово.
  \item \texttt{e.ANY} --- произвольное объектное выражение.
\end{itemize}

Символы \texttt{*} и \texttt{+} означают повторение литерала ноль и более и
один и более раз соответственно.

\subsection{Составляющие уравнения}

Рассматриваются уравнения в словах с алфавитом переменных $\Xi$ и алфавитом
констант $\Sigma$. Применение алгоритма Jez'а предполагает хранение
дополнительной информации об уравнении: какие константы являются результатом
сжатия блоков, какие переменные не могут быть пусты и т.д. Поэтому
\textit{уравнение} представляется структурой данных \texttt{t.Eq}:
\begin{Verbatim}
  t.Eq ::= ((AreEqual (t.Elem*) (t.Elem*)) (t.Constr*) (t.Cond*)),
\end{Verbatim}
где \texttt{(t.Elem*)} есть левая и правая части уравнения, \texttt{(t.Constr*)}
--- ограничения на переменные, а \texttt{(t.Cond*)} содержит условия на
константы.

\textit{Элемент} \texttt{t.Elem} обобщённо представляет \textit{константу} или
\textit{переменную}, соответствующие структурам данных \texttt{t.Const} и
\texttt{t.Var}:
\begin{Verbatim}
  t.Elem ::= t.Var | t.Elem,
  t.Var ::= (Var s.CHAR),
  t.Const ::= (s.CHAR s.NUMBER).
\end{Verbatim}

\subsection{Ограничения на переменные}

\textit{Ограничение на переменную} представляется структурой \texttt{t.Constr}
и описывается в конъюнктивной нормальной форме. Литералами дизъюнкций являются
\textit{рестрикции} (отрицательные условия на переменные) типа \texttt{t.Restr},
подразделяющиеся на \textit{краевые} \texttt{t.BoundRestr} и рестрикции
\textit{на пустоту} \texttt{t.EmptyRestr}:
\begin{Verbatim}
  t.Restr ::= t.BoundRestr | t.EmptyRestr.
\end{Verbatim}

Краевые рестрикции бывают \textit{префиксными} \texttt{t.PrefixRestr} и
\textit{суффиксными} \texttt{t.SuffixRestr}. Они указывают, на какие константы
не может начинаться (кончаться) данная переменная.
\begin{Verbatim}
  t.BoundRestr ::= t.PrefixRestr | t.SuffixRestr,
  t.PrefixRestr ::= (not t.Const starts t.Var),
  t.SuffixRestr ::= (not t.Const ends t.Var).
\end{Verbatim}

Рестрикция на пустоту \texttt{t.EmptyRestr} сообщает, как следует, о
невозможности обращения данной переменной в пустое слово $\varepsilon$:
\begin{Verbatim}
  t.EmptyRestr ::= (not empty t.Var).
\end{Verbatim}

Ограничения на переменные \texttt{t.Constr} могут содержать одну или две
рестрикции, в соответствии с чем называются \textit{тривиальными}
\texttt{t.TrivialConstr} и \textit{нетривиальными} \texttt{t.NonTrivialConstr}.
В программе используется только четыре вида ограничений:
\begin{Verbatim}
  t.Constr ::= t.TrivialConstr | t.NonTrivialConstr
  t.TrivialConstr ::= (OR t.Restr),
  t.NonTrivialConstr ::= (OR t.SuffixRestr t.PrefixRestr).
\end{Verbatim}

Говоря далее ограничения мы, как правило, будем подразумевать именно
тривиальные, если не оговорено противное, а также будем экстраполировать
тип рестрикции на ограничение её содержащее: префиксное ограничение,
ограничение на пустоту и т.д.

\subsection{Условия на константы}

\textit{Условие на константу} \texttt{t.Cond} содержит сжимаемые блоки и
соотвествующую этому сжатию константу. Вообще, \textit{блок} \texttt{t.Block}
обозначает степень константы и представляется в виде
\begin{Verbatim}
  t.Block ::= (t.Const t.Exp* (const s.NUMBER)),
\end{Verbatim}
где \texttt{t.Const} --- сжимаемая константа, \texttt{(const s.NUMBER)} ---
обязательный константный показатель, а \texttt{t.Exp ::= (s.WORD s.NUMBER)}
--- переменный показатель степени. Таким образом, условие на константу
представляется в виде
\begin{Verbatim}
  t.Cond ::= (t.Const is t.Block+)
\end{Verbatim}
В программе используется только два типа условий: \textit{парное условие}
\texttt{t.PairCond} и \textit{условие на блок} \texttt{t.BlockCond}:
\begin{Verbatim}
  t.PairCond ::= (t.Const is (t.Const (const 1)) (t.Const (const 1))),
  t.BlockCond ::= (t.Const is t.Block).
\end{Verbatim}

\subsection{Краевые элементы}

Мы хотим применять \texttt{Pair}- и \texttt{Block}-сжатие не только к
тривиальным константам, но и тем, что уже являются результатом сжатия в блоки.
Для корректной обработки ограничений необходимо аккуратно отслеживать, на какие
константы не может начинаться (кончаться) та или иная переменная.

Пусть $\alpha, \gamma \in \Sigma$. Скажем, что $\alpha \in First(\gamma)$, если
существует цепочка условий на константы такая, что
\begin{displaymath}
  \gamma = \beta_1^{i_1} B_1,
  \beta_1 = \beta_2^{i_2} B_2,
  \dots,
  \beta_{n-1} = \alpha^{i_n} B_n,
\end{displaymath}
где $\beta_i \in \Sigma, i = 1, 2, \dots, n - 1$, и $B_j \subset \Sigma, j = 1,
2, \dots, n$. Симметрично определяется множество $Last$-элементов константы.

Иногда удобно использовать обобщение введённых выше понятий: будем
говорить, что константа $\alpha$ является \textbf{краевым} элементом константы
$\gamma$, если $\alpha \in First(\gamma)$ или $\alpha \in Last(\gamma)$.
Обозначение: $\alpha \in Bound(\gamma)$.

\subsection{Слабые и сильные ограничения}

В соответствие с введённым выше понятием краевого элемента, для данной
переменной $X$ и константы $\gamma$ мы можем ввести \textit{иерархические
отношения} на множествах префиксных и суффиксных ограничений $X$ с константами
$First(\gamma)$ и $Last(\gamma)$ соответственно.

Пусть даны два таких ограничения одного типа с константами $\alpha$ и $\beta$.
Если $\alpha \in Bound(\beta)$, то $\alpha$-ограничение является
\textbf{более сильным}. В то же время $\beta$-ограничение есть
\textbf{более слабое} по сравнению с первым.

Имеет смысл хранить в уравнении лишь самые сильные ограничения.

\subsection{Избыточные рестрикции и условия}

В результате некоторых действий какие-то рестрикции могут стать неактуальными,
вследствие чего их желательно удалять из уравнения.

Скажем, что рестрикция \textbf{избыточная}, если участвующей в ней константы
нет в уравнении, а также в правых частях условий на константы.

Как и рестрикция, условие (на константу) также может стать \textbf{избыточным}.
Это происходит в двух случаях:
\begin{itemize}
  \item константа в левой части условия не участвует в уравнении и не является
  $Bound$-элементом какой-либо другой константы;
  \item условие имеет парный тип, обеих констант его правой части нет
  в уравнении и они не являются левыми частями каких-либо других условий.
\end{itemize}

\subsection{Нормальное уравнение}

Скажем, что уравнение \textbf{несократимо}, если его левая и правая части не
имеют совпадающих префиксов и суффиксов.

Будем называть уравнение \textbf{нормальным}, если оно несократимо, не содержит
слабых (краевых) ограничений и избыточных рестрикций и условий. Также
потребуем, чтобы в нормальном уравнении все ограничения были отсортированы,
равно как и показатели степеней \texttt{t.Exp} условий на блок.

Нормальные уравнения представляют особый интерес для нас. Именно такие уравнения
возращают и ожидают получить на вход функции \texttt{Pick}, \texttt{SubstIndex},
\texttt{PairComp} и \texttt{BlockComp}.

\end{document}

